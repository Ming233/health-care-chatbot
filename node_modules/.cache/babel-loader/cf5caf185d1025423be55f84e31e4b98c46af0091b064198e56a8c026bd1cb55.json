{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar ScalarObservable_1 = require('./ScalarObservable');\nvar EmptyObservable_1 = require('./EmptyObservable');\nvar isScheduler_1 = require('../util/isScheduler');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayObservable = function (_super) {\n  __extends(ArrayObservable, _super);\n  function ArrayObservable(array, scheduler) {\n    _super.call(this);\n    this.array = array;\n    this.scheduler = scheduler;\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n  ArrayObservable.create = function (array, scheduler) {\n    return new ArrayObservable(array, scheduler);\n  };\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n  ArrayObservable.of = function () {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      array[_i - 0] = arguments[_i];\n    }\n    var scheduler = array[array.length - 1];\n    if (isScheduler_1.isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n    var len = array.length;\n    if (len > 1) {\n      return new ArrayObservable(array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n    } else {\n      return new EmptyObservable_1.EmptyObservable(scheduler);\n    }\n  };\n  ArrayObservable.dispatch = function (state) {\n    var array = state.array,\n      index = state.index,\n      count = state.count,\n      subscriber = state.subscriber;\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n    subscriber.next(array[index]);\n    if (subscriber.closed) {\n      return;\n    }\n    state.index = index + 1;\n    this.schedule(state);\n  };\n  /** @deprecated internal use only */\n  ArrayObservable.prototype._subscribe = function (subscriber) {\n    var index = 0;\n    var array = this.array;\n    var count = array.length;\n    var scheduler = this.scheduler;\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array: array,\n        index: index,\n        count: count,\n        subscriber: subscriber\n      });\n    } else {\n      for (var i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n      subscriber.complete();\n    }\n  };\n  return ArrayObservable;\n}(Observable_1.Observable);\nexports.ArrayObservable = ArrayObservable;","map":{"version":3,"mappings":";;;;;;;;;AACA,2BAA2B,eAAe,CAAC;AAC3C,iCAAiC,oBAAoB,CAAC;AACtD,gCAAgC,mBAAmB,CAAC;AAEpD,4BAA4B,qBAAqB,CAAC;AAGlD;;;;;AAKA;EAAwCA;EA0FtC,yBAAoBC,KAAU,EAAUC,SAAsB;IAC5DC,iBAAO;IADW,UAAK,GAALF,KAAK;IAAe,cAAS,GAATC,SAAS;IAE/C,IAAI,CAACA,SAAS,IAAID,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;MACpC,IAAI,CAACC,SAAS,GAAG,IAAI;MACrB,IAAI,CAACC,KAAK,GAAGL,KAAK,CAAC,CAAC,CAAC;IACvB;EACF;EA9FOM,sBAAM,GAAb,UAAiBN,KAAU,EAAEC,SAAsB;IACjD,OAAO,IAAIK,eAAe,CAACN,KAAK,EAAEC,SAAS,CAAC;EAC9C,CAAC;EASD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAoCOK,kBAAE,GAAT;IAAa;SAAA,uCAA+B;MAA/BN;;IACX,IAAIC,SAAS,GAAeD,KAAK,CAACA,KAAK,CAACG,MAAM,GAAG,CAAC,CAAC;IACnD,IAAII,yBAAW,CAACN,SAAS,CAAC,EAAE;MAC1BD,KAAK,CAACQ,GAAG,EAAE;IACb,CAAC,MAAM;MACLP,SAAS,GAAG,IAAI;IAClB;IAEA,IAAMQ,GAAG,GAAGT,KAAK,CAACG,MAAM;IACxB,IAAIM,GAAG,GAAG,CAAC,EAAE;MACX,OAAO,IAAIH,eAAe,CAASN,KAAK,EAAEC,SAAS,CAAC;IACtD,CAAC,MAAM,IAAIQ,GAAG,KAAK,CAAC,EAAE;MACpB,OAAO,IAAIC,mCAAgB,CAASV,KAAK,CAAC,CAAC,CAAC,EAAEC,SAAS,CAAC;IAC1D,CAAC,MAAM;MACL,OAAO,IAAIU,iCAAe,CAAIV,SAAS,CAAC;IAC1C;EACF,CAAC;EAEMK,wBAAQ,GAAf,UAAgBM,KAAU;IAEhB,uBAAK;MAAEC,mBAAK;MAAEC,mBAAK;MAAEC,6BAAU;IAEvC,IAAIF,KAAK,IAAIC,KAAK,EAAE;MAClBC,UAAU,CAACC,QAAQ,EAAE;MACrB;IACF;IAEAD,UAAU,CAACE,IAAI,CAACjB,KAAK,CAACa,KAAK,CAAC,CAAC;IAE7B,IAAIE,UAAU,CAACG,MAAM,EAAE;MACrB;IACF;IAEAN,KAAK,CAACC,KAAK,GAAGA,KAAK,GAAG,CAAC;IAEhB,IAAK,CAACM,QAAQ,CAACP,KAAK,CAAC;EAC9B,CAAC;EAaD;EAAqCN,oCAAU,GAAV,UAAWS,UAAyB;IACvE,IAAIF,KAAK,GAAG,CAAC;IACb,IAAMb,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,IAAMc,KAAK,GAAGd,KAAK,CAACG,MAAM;IAC1B,IAAMF,SAAS,GAAG,IAAI,CAACA,SAAS;IAEhC,IAAIA,SAAS,EAAE;MACb,OAAOA,SAAS,CAACkB,QAAQ,CAACb,eAAe,CAACc,QAAQ,EAAE,CAAC,EAAE;QACrDpB,YAAK;QAAEa,YAAK;QAAEC,YAAK;QAAEC;OACtB,CAAC;IACJ,CAAC,MAAM;MACL,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,IAAI,CAACC,UAAU,CAACG,MAAM,EAAEG,CAAC,EAAE,EAAE;QACpDN,UAAU,CAACE,IAAI,CAACjB,KAAK,CAACqB,CAAC,CAAC,CAAC;MAC3B;MACAN,UAAU,CAACC,QAAQ,EAAE;IACvB;EACF,CAAC;EACH,sBAAC;AAAD,CAAC,CAnHuCM,uBAAU;AAArCC,uBAAe,kBAmH3B","names":["__extends","array","scheduler","_super","length","_isScalar","value","ArrayObservable","isScheduler_1","pop","len","ScalarObservable_1","EmptyObservable_1","state","index","count","subscriber","complete","next","closed","schedule","dispatch","i","Observable_1","exports"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\src\\observable\\ArrayObservable.ts"],"sourcesContent":["import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ScalarObservable } from './ScalarObservable';\nimport { EmptyObservable } from './EmptyObservable';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ArrayObservable<T> extends Observable<T> {\n\n  static create<T>(array: T[], scheduler?: IScheduler): Observable<T> {\n    return new ArrayObservable(array, scheduler);\n  }\n\n  static of<T>(item1: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, item6: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(...array: Array<T | IScheduler>): Observable<T>;\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n  static of<T>(...array: Array<T | IScheduler>): Observable<T> {\n    let scheduler = <IScheduler>array[array.length - 1];\n    if (isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    const len = array.length;\n    if (len > 1) {\n      return new ArrayObservable<T>(<any>array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable<T>(<any>array[0], scheduler);\n    } else {\n      return new EmptyObservable<T>(scheduler);\n    }\n  }\n\n  static dispatch(state: any) {\n\n    const { array, index, count, subscriber } = state;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(array[index]);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n\n    (<any> this).schedule(state);\n  }\n\n  // value used if Array has one value and _isScalar\n  value: any;\n\n  constructor(private array: T[], private scheduler?: IScheduler) {\n    super();\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    let index = 0;\n    const array = this.array;\n    const count = array.length;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array, index, count, subscriber\n      });\n    } else {\n      for (let i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n      subscriber.complete();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}