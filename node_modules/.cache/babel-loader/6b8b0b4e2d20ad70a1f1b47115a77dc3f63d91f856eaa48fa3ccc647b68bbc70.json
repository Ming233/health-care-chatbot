{"ast":null,"code":"\"use strict\";\n\nvar root_1 = require('./root');\nvar isArrayLike_1 = require('./isArrayLike');\nvar isPromise_1 = require('./isPromise');\nvar isObject_1 = require('./isObject');\nvar Observable_1 = require('../Observable');\nvar iterator_1 = require('../symbol/iterator');\nvar InnerSubscriber_1 = require('../InnerSubscriber');\nvar observable_1 = require('../symbol/observable');\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n  var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n  if (destination.closed) {\n    return null;\n  }\n  if (result instanceof Observable_1.Observable) {\n    if (result._isScalar) {\n      destination.next(result.value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike_1.isArrayLike(result)) {\n    for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise_1.isPromise(result)) {\n    result.then(function (value) {\n      if (!destination.closed) {\n        destination.next(value);\n        destination.complete();\n      }\n    }, function (err) {\n      return destination.error(err);\n    }).then(null, function (err) {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root_1.root.setTimeout(function () {\n        throw err;\n      });\n    });\n    return destination;\n  } else if (result && typeof result[iterator_1.iterator] === 'function') {\n    var iterator = result[iterator_1.iterator]();\n    do {\n      var item = iterator.next();\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n      destination.next(item.value);\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[observable_1.observable] === 'function') {\n    var obs = result[observable_1.observable]();\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n    var msg = \"You provided \" + value + \" where a stream was expected.\" + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n  return null;\n}\nexports.subscribeToResult = subscribeToResult;","map":{"version":3,"mappings":"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","names":["outerSubscriber","result","outerValue","outerIndex","destination","InnerSubscriber_1","closed","Observable_1","_isScalar","next","value","complete","syncErrorThrowable","subscribe","isArrayLike_1","i","len","length","isPromise_1","then","err","error","root_1","setTimeout","iterator_1","iterator","item","done","observable_1","obs","TypeError","isObject_1","msg","exports"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\src\\util\\subscribeToResult.ts"],"sourcesContent":["import { root } from './root';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, ObservableInput } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>,\n                                        result: any,\n                                        outerValue?: T,\n                                        outerIndex?: number): Subscription;\nexport function subscribeToResult<T>(outerSubscriber: OuterSubscriber<any, any>,\n                                     result: ObservableInput<T>,\n                                     outerValue?: T,\n                                     outerIndex?: number): Subscription {\n  let destination: Subscriber<any> = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  if (destination.closed) {\n    return null;\n  }\n\n  if (result instanceof Observable) {\n    if (result._isScalar) {\n      destination.next((<any>result).value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike(result)) {\n    for (let i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise(result)) {\n    result.then(\n      (value) => {\n        if (!destination.closed) {\n          destination.next(<any>value);\n          destination.complete();\n        }\n      },\n      (err: any) => destination.error(err)\n    )\n    .then(null, (err: any) => {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root.setTimeout(() => { throw err; });\n    });\n    return destination;\n  } else if (result && typeof result[Symbol_iterator] === 'function') {\n    const iterator = <any>result[Symbol_iterator]();\n    do {\n      let item = iterator.next();\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n      destination.next(item.value);\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[Symbol_observable] === 'function') {\n    const obs = result[Symbol_observable]();\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}