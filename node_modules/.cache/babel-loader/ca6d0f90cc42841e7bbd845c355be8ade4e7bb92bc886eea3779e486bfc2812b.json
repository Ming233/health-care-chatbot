{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n  return function mergeMapOperatorFunction(source) {\n    if (typeof resultSelector === 'number') {\n      concurrent = resultSelector;\n      resultSelector = null;\n    }\n    return source.lift(new MergeMapOperator(project, resultSelector, concurrent));\n  };\n}\nexports.mergeMap = mergeMap;\nvar MergeMapOperator = function () {\n  function MergeMapOperator(project, resultSelector, concurrent) {\n    if (concurrent === void 0) {\n      concurrent = Number.POSITIVE_INFINITY;\n    }\n    this.project = project;\n    this.resultSelector = resultSelector;\n    this.concurrent = concurrent;\n  }\n  MergeMapOperator.prototype.call = function (observer, source) {\n    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n  };\n  return MergeMapOperator;\n}();\nexports.MergeMapOperator = MergeMapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapSubscriber = function (_super) {\n  __extends(MergeMapSubscriber, _super);\n  function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n    if (concurrent === void 0) {\n      concurrent = Number.POSITIVE_INFINITY;\n    }\n    _super.call(this, destination);\n    this.project = project;\n    this.resultSelector = resultSelector;\n    this.concurrent = concurrent;\n    this.hasCompleted = false;\n    this.buffer = [];\n    this.active = 0;\n    this.index = 0;\n  }\n  MergeMapSubscriber.prototype._next = function (value) {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  };\n  MergeMapSubscriber.prototype._tryNext = function (value) {\n    var result;\n    var index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.active++;\n    this._innerSub(result, value, index);\n  };\n  MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n    this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n  };\n  MergeMapSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n  };\n  MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    if (this.resultSelector) {\n      this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      this.destination.next(innerValue);\n    }\n  };\n  MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n    var result;\n    try {\n      result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  };\n  MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n    var buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n  return MergeMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\nexports.MergeMapSubscriber = MergeMapSubscriber;","map":{"version":3,"mappings":";;;;;;;;;AAIA,kCAAkC,2BAA2B,CAAC;AAC9D,gCAAgC,oBAAoB,CAAC;AAOrD;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0DA,kBAAkCA,OAAwD,EACxDC,cAAuG,EACvGC,UAA6C;EAA7C,2BAA6C;IAA7CA,aAAqBC,MAAM,CAACC,iBAAiB;EAAA;EAC7E,OAAO,kCAAkCC,MAAqB;IAC5D,IAAI,OAAOJ,cAAc,KAAK,QAAQ,EAAE;MACtCC,UAAU,GAAWD,cAAc;MACnCA,cAAc,GAAG,IAAI;IACvB;IACA,OAAOI,MAAM,CAACC,IAAI,CAAC,IAAIC,gBAAgB,CAACP,OAAO,EAAOC,cAAc,EAAEC,UAAU,CAAC,CAAC;EACpF,CAAC;AACH;AAVgBM,gBAAQ,WAUvB;AAED;EACE,0BAAoBR,OAAwD,EACxDC,cAA4F,EAC5FC,UAA6C;IAArD,2BAAqD;MAArDA,aAA6BC,MAAM,CAACC,iBAAiB;IAAA;IAF7C,YAAO,GAAPJ,OAAO;IACP,mBAAc,GAAdC,cAAc;IACd,eAAU,GAAVC,UAAU;EAC9B;EAEAK,+BAAI,GAAJ,UAAKE,QAAuB,EAAEJ,MAAW;IACvC,OAAOA,MAAM,CAACK,SAAS,CAAC,IAAIC,kBAAkB,CAC5CF,QAAQ,EAAE,IAAI,CAACT,OAAO,EAAE,IAAI,CAACC,cAAc,EAAE,IAAI,CAACC,UAAU,CAC7D,CAAC;EACJ,CAAC;EACH,uBAAC;AAAD,CAAC,EAXD;AAAaM,wBAAgB,mBAW5B;AAED;;;;;AAKA;EAAiDI;EAM/C,4BAAYC,WAA0B,EAClBb,OAAwD,EACxDC,cAA4F,EAC5FC,UAA6C;IAArD,2BAAqD;MAArDA,aAA6BC,MAAM,CAACC,iBAAiB;IAAA;IAC/DU,kBAAMD,WAAW,CAAC;IAHA,YAAO,GAAPb,OAAO;IACP,mBAAc,GAAdC,cAAc;IACd,eAAU,GAAVC,UAAU;IARtB,iBAAY,GAAY,KAAK;IAC7B,WAAM,GAAQ,EAAE;IAChB,WAAM,GAAW,CAAC;IAChB,UAAK,GAAW,CAAC;EAO3B;EAEUS,kCAAK,GAAf,UAAgBI,KAAQ;IACtB,IAAI,IAAI,CAACC,MAAM,GAAG,IAAI,CAACd,UAAU,EAAE;MACjC,IAAI,CAACe,QAAQ,CAACF,KAAK,CAAC;IACtB,CAAC,MAAM;MACL,IAAI,CAACG,MAAM,CAACC,IAAI,CAACJ,KAAK,CAAC;IACzB;EACF,CAAC;EAESJ,qCAAQ,GAAlB,UAAmBI,KAAQ;IACzB,IAAIK,MAA0B;IAC9B,IAAMC,KAAK,GAAG,IAAI,CAACA,KAAK,EAAE;IAC1B,IAAI;MACFD,MAAM,GAAG,IAAI,CAACpB,OAAO,CAACe,KAAK,EAAEM,KAAK,CAAC;IACrC,CAAE,QAAOC,GAAG,EAAE;MACZ,IAAI,CAACT,WAAW,CAACU,KAAK,CAACD,GAAG,CAAC;MAC3B;IACF;IACA,IAAI,CAACN,MAAM,EAAE;IACb,IAAI,CAACQ,SAAS,CAACJ,MAAM,EAAEL,KAAK,EAAEM,KAAK,CAAC;EACtC,CAAC;EAEOV,sCAAS,GAAjB,UAAkBc,GAAuB,EAAEV,KAAQ,EAAEM,KAAa;IAChE,IAAI,CAACK,GAAG,CAACC,qCAAiB,CAAO,IAAI,EAAEF,GAAG,EAAEV,KAAK,EAAEM,KAAK,CAAC,CAAC;EAC5D,CAAC;EAESV,sCAAS,GAAnB;IACE,IAAI,CAACiB,YAAY,GAAG,IAAI;IACxB,IAAI,IAAI,CAACZ,MAAM,KAAK,CAAC,IAAI,IAAI,CAACE,MAAM,CAACW,MAAM,KAAK,CAAC,EAAE;MACjD,IAAI,CAAChB,WAAW,CAACiB,QAAQ,EAAE;IAC7B;EACF,CAAC;EAEDnB,uCAAU,GAAV,UAAWoB,UAAa,EAAEC,UAAa,EAC5BC,UAAkB,EAAEC,UAAkB,EACtCC,QAA+B;IACxC,IAAI,IAAI,CAAClC,cAAc,EAAE;MACvB,IAAI,CAACmC,qBAAqB,CAACL,UAAU,EAAEC,UAAU,EAAEC,UAAU,EAAEC,UAAU,CAAC;IAC5E,CAAC,MAAM;MACL,IAAI,CAACrB,WAAW,CAACwB,IAAI,CAACL,UAAU,CAAC;IACnC;EACF,CAAC;EAEOrB,kDAAqB,GAA7B,UAA8BoB,UAAa,EAAEC,UAAa,EAAEC,UAAkB,EAAEC,UAAkB;IAChG,IAAId,MAAS;IACb,IAAI;MACFA,MAAM,GAAG,IAAI,CAACnB,cAAc,CAAC8B,UAAU,EAAEC,UAAU,EAAEC,UAAU,EAAEC,UAAU,CAAC;IAC9E,CAAE,QAAOZ,GAAG,EAAE;MACZ,IAAI,CAACT,WAAW,CAACU,KAAK,CAACD,GAAG,CAAC;MAC3B;IACF;IACA,IAAI,CAACT,WAAW,CAACwB,IAAI,CAACjB,MAAM,CAAC;EAC/B,CAAC;EAEDT,2CAAc,GAAd,UAAewB,QAAsB;IACnC,IAAMjB,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,IAAI,CAACoB,MAAM,CAACH,QAAQ,CAAC;IACrB,IAAI,CAACnB,MAAM,EAAE;IACb,IAAIE,MAAM,CAACW,MAAM,GAAG,CAAC,EAAE;MACrB,IAAI,CAACU,KAAK,CAACrB,MAAM,CAACsB,KAAK,EAAE,CAAC;IAC5B,CAAC,MAAM,IAAI,IAAI,CAACxB,MAAM,KAAK,CAAC,IAAI,IAAI,CAACY,YAAY,EAAE;MACjD,IAAI,CAACf,WAAW,CAACiB,QAAQ,EAAE;IAC7B;EACF,CAAC;EACH,yBAAC;AAAD,CAAC,CA5EgDW,iCAAe;AAAnDjC,0BAAkB,qBA4E9B","names":["project","resultSelector","concurrent","Number","POSITIVE_INFINITY","source","lift","MergeMapOperator","exports","observer","subscribe","MergeMapSubscriber","__extends","destination","_super","value","active","_tryNext","buffer","push","result","index","err","error","_innerSub","ish","add","subscribeToResult_1","hasCompleted","length","complete","outerValue","innerValue","outerIndex","innerIndex","innerSub","_notifyResultSelector","next","remove","_next","shift","OuterSubscriber_1"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\src\\operators\\mergeMap.ts"],"sourcesContent":["import { Observable, ObservableInput } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number): OperatorFunction<T, R>;\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>,\n                                  resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number,\n                                  concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<T, I|R> {\n  return function mergeMapOperatorFunction(source: Observable<T>) {\n    if (typeof resultSelector === 'number') {\n      concurrent = <number>resultSelector;\n      resultSelector = null;\n    }\n    return source.lift(new MergeMapOperator(project, <any>resultSelector, concurrent));\n  };\n}\n\nexport class MergeMapOperator<T, I, R> implements Operator<T, I> {\n  constructor(private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n  }\n\n  call(observer: Subscriber<I>, source: any): any {\n    return source.subscribe(new MergeMapSubscriber(\n      observer, this.project, this.resultSelector, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private hasCompleted: boolean = false;\n  private buffer: T[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<I>,\n              private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  protected _tryNext(value: T) {\n    let result: ObservableInput<I>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.active++;\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(ish: ObservableInput<I>, value: T, index: number): void {\n    this.add(subscribeToResult<T, I>(this, ish, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    if (this.resultSelector) {\n      this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      this.destination.next(innerValue);\n    }\n  }\n\n  private _notifyResultSelector(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) {\n    let result: R;\n    try {\n      result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}