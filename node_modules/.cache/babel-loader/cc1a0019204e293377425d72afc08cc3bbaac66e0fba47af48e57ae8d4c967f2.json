{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @module botframework-streaming\n */\n/**\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar subscribableStream_1 = require(\"../subscribableStream\");\nvar payloads_1 = require(\"../payloads\");\nvar contentStream_1 = require(\"../contentStream\");\n/**\n * Assembles payloads for streaming library.\n */\nvar PayloadAssembler = /** @class */function () {\n  function PayloadAssembler(streamManager, params) {\n    this._byteOrderMark = 0xFEFF;\n    this._utf = 'utf8';\n    if (params.header) {\n      this.id = params.header.id;\n      this.payloadType = params.header.payloadType;\n      this.contentLength = params.header.payloadLength;\n      this.end = params.header.end;\n    } else {\n      this.id = params.id;\n    }\n    if (!this.id) {\n      throw Error('An ID must be supplied when creating an assembler.');\n    }\n    this._streamManager = streamManager;\n    this._onCompleted = params.onCompleted;\n  }\n  PayloadAssembler.prototype.getPayloadStream = function () {\n    if (!this.stream) {\n      this.stream = this.createPayloadStream();\n    }\n    return this.stream;\n  };\n  PayloadAssembler.prototype.onReceive = function (header, stream, contentLength) {\n    this.end = header.end;\n    if (header.payloadType === payloads_1.PayloadTypes.response || header.payloadType === payloads_1.PayloadTypes.request) {\n      this.process(stream).then().catch();\n    } else if (header.end) {\n      stream.end();\n    }\n  };\n  PayloadAssembler.prototype.close = function () {\n    this._streamManager.closeStream(this.id);\n  };\n  PayloadAssembler.prototype.createPayloadStream = function () {\n    return new subscribableStream_1.SubscribableStream();\n  };\n  PayloadAssembler.prototype.payloadFromJson = function (json) {\n    return JSON.parse(json.charCodeAt(0) === this._byteOrderMark ? json.slice(1) : json);\n  };\n  PayloadAssembler.prototype.stripBOM = function (input) {\n    return input.charCodeAt(0) === this._byteOrderMark ? input.slice(1) : input;\n  };\n  PayloadAssembler.prototype.process = function (stream) {\n    return __awaiter(this, void 0, void 0, function () {\n      var streamData, streamDataAsString;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            streamData = stream.read(stream.length);\n            if (!streamData) {\n              return [2 /*return*/];\n            }\n\n            streamDataAsString = streamData.toString(this._utf);\n            if (!(this.payloadType === payloads_1.PayloadTypes.request)) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.processRequest(streamDataAsString)];\n          case 1:\n            _a.sent();\n            return [3 /*break*/, 4];\n          case 2:\n            if (!(this.payloadType === payloads_1.PayloadTypes.response)) return [3 /*break*/, 4];\n            return [4 /*yield*/, this.processResponse(streamDataAsString)];\n          case 3:\n            _a.sent();\n            _a.label = 4;\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  PayloadAssembler.prototype.processResponse = function (streamDataAsString) {\n    return __awaiter(this, void 0, void 0, function () {\n      var responsePayload, receiveResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            responsePayload = this.payloadFromJson(this.stripBOM(streamDataAsString));\n            receiveResponse = {\n              streams: [],\n              statusCode: responsePayload.statusCode\n            };\n            return [4 /*yield*/, this.processStreams(responsePayload, receiveResponse)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  PayloadAssembler.prototype.processRequest = function (streamDataAsString) {\n    return __awaiter(this, void 0, void 0, function () {\n      var requestPayload, receiveRequest;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            requestPayload = this.payloadFromJson(streamDataAsString);\n            receiveRequest = {\n              streams: [],\n              path: requestPayload.path,\n              verb: requestPayload.verb\n            };\n            return [4 /*yield*/, this.processStreams(requestPayload, receiveRequest)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  PayloadAssembler.prototype.processStreams = function (responsePayload, receiveResponse) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (responsePayload.streams) {\n              responsePayload.streams.forEach(function (responseStream) {\n                var contentAssembler = _this._streamManager.getPayloadAssembler(responseStream.id);\n                contentAssembler.payloadType = responseStream.contentType;\n                contentAssembler.contentLength = responseStream.length;\n                receiveResponse.streams.push(new contentStream_1.ContentStream(responseStream.id, contentAssembler));\n              });\n            }\n            return [4 /*yield*/, this._onCompleted(this.id, receiveResponse)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return PayloadAssembler;\n}();\nexports.PayloadAssembler = PayloadAssembler;","map":{"version":3,"mappings":"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","names":["streamManager","params","header","id","payloadType","contentLength","payloadLength","end","Error","_streamManager","_onCompleted","onCompleted","PayloadAssembler","stream","createPayloadStream","payloads_1","response","request","process","then","catch","closeStream","subscribableStream_1","json","JSON","parse","charCodeAt","_byteOrderMark","slice","input","streamData","read","length","streamDataAsString","toString","_utf","processRequest","_a","processResponse","responsePayload","payloadFromJson","stripBOM","receiveResponse","streams","statusCode","processStreams","requestPayload","receiveRequest","path","verb","forEach","responseStream","contentAssembler","_this","getPayloadAssembler","contentType","push","contentStream_1","exports"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\botframework-streaming\\src\\assemblers\\payloadAssembler.ts"],"sourcesContent":["/**\r\n * @module botframework-streaming\r\n */\r\n/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { SubscribableStream } from '../subscribableStream';\r\nimport { StreamManager, PayloadTypes } from '../payloads';\r\nimport { ContentStream } from '../contentStream';\r\nimport { IAssemblerParams } from '../interfaces/IAssemblerParams';\r\nimport { IHeader } from '../interfaces/IHeader';\r\nimport { IResponsePayload } from '../interfaces/IResponsePayload';\r\nimport { IReceiveResponse, IReceiveRequest } from '../interfaces';\r\nimport { IRequestPayload } from '../interfaces/IRequestPayload';\r\n\r\n/**\r\n * Assembles payloads for streaming library.\r\n */\r\nexport class PayloadAssembler {\r\n    public id: string;\r\n    public end: boolean;\r\n    public contentLength: number;\r\n    public payloadType: string;\r\n    private stream: SubscribableStream;\r\n    private readonly _onCompleted: Function;\r\n    private readonly _streamManager: StreamManager;\r\n    private readonly _byteOrderMark = 0xFEFF;\r\n    private readonly _utf: string = 'utf8';\r\n\r\n    public constructor(streamManager: StreamManager, params: IAssemblerParams) {\r\n        if(params.header){\r\n            this.id = params.header.id;\r\n            this.payloadType = params.header.payloadType;\r\n            this.contentLength = params.header.payloadLength;\r\n            this.end = params.header.end;\r\n        } else {\r\n            this.id = params.id;\r\n        }\r\n\r\n        if(!this.id){\r\n            throw Error('An ID must be supplied when creating an assembler.');\r\n        }\r\n\r\n        this._streamManager = streamManager;\r\n        this._onCompleted = params.onCompleted;\r\n    }\r\n\r\n    public getPayloadStream(): SubscribableStream {\r\n        if (!this.stream) {\r\n            this.stream = this.createPayloadStream();\r\n        }\r\n\r\n        return this.stream;\r\n    }\r\n\r\n    public onReceive(header: IHeader, stream: SubscribableStream, contentLength: number): void {\r\n        this.end = header.end;\r\n\r\n        if (header.payloadType === PayloadTypes.response || header.payloadType === PayloadTypes.request) {\r\n            this.process(stream)\r\n                .then()\r\n                .catch();\r\n        } else if (header.end) {\r\n            stream.end();\r\n        }\r\n    }\r\n\r\n    public close(): void {\r\n        this._streamManager.closeStream(this.id);\r\n    }\r\n\r\n    private createPayloadStream(): SubscribableStream {\r\n        return new SubscribableStream();\r\n    }\r\n\r\n    private payloadFromJson<T>(json: string): T {\r\n        return JSON.parse((json.charCodeAt(0) === this._byteOrderMark) ? json.slice(1) : json) as T;\r\n    }\r\n\r\n    private stripBOM(input: string): string {\r\n        return (input.charCodeAt(0) === this._byteOrderMark) ? input.slice(1) : input;\r\n    }\r\n\r\n    private async process(stream: SubscribableStream): Promise<void> {\r\n        let streamData: Buffer = stream.read(stream.length) as Buffer;\r\n        if (!streamData) {\r\n            return;\r\n        }\r\n\r\n        let streamDataAsString = streamData.toString(this._utf);\r\n\r\n        if(this.payloadType === PayloadTypes.request){\r\n            await this.processRequest(streamDataAsString);\r\n        } else if(this.payloadType === PayloadTypes.response){\r\n            await this.processResponse(streamDataAsString);\r\n        }\r\n    }\r\n\r\n    private async processResponse(streamDataAsString: string): Promise<void> {\r\n\r\n        let responsePayload: IResponsePayload = this.payloadFromJson(this.stripBOM(streamDataAsString));\r\n        let receiveResponse: IReceiveResponse = { streams: [], statusCode: responsePayload.statusCode };\r\n\r\n        await this.processStreams(responsePayload, receiveResponse);\r\n    }\r\n\r\n    private async processRequest(streamDataAsString: string): Promise<void> {\r\n\r\n        let requestPayload: IRequestPayload = this.payloadFromJson(streamDataAsString);\r\n        let receiveRequest: IReceiveRequest = { streams: [], path: requestPayload.path, verb: requestPayload.verb };\r\n\r\n        await this.processStreams(requestPayload, receiveRequest);\r\n    }\r\n\r\n    private async processStreams(responsePayload: any, receiveResponse: any) {\r\n        if (responsePayload.streams) {\r\n            responsePayload.streams.forEach((responseStream): void => {\r\n                let contentAssembler: PayloadAssembler = this._streamManager.getPayloadAssembler(responseStream.id);\r\n                contentAssembler.payloadType = responseStream.contentType;\r\n                contentAssembler.contentLength = responseStream.length;\r\n                receiveResponse.streams.push(new ContentStream(responseStream.id, contentAssembler));\r\n            });\r\n        }\r\n        await this._onCompleted(this.id, receiveResponse);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}