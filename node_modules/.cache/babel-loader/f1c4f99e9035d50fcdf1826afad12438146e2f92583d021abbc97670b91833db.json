{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n  return function filterOperatorFunction(source) {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\nexports.filter = filter;\nvar FilterOperator = function () {\n  function FilterOperator(predicate, thisArg) {\n    this.predicate = predicate;\n    this.thisArg = thisArg;\n  }\n  FilterOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  };\n  return FilterOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = function (_super) {\n  __extends(FilterSubscriber, _super);\n  function FilterSubscriber(destination, predicate, thisArg) {\n    _super.call(this, destination);\n    this.predicate = predicate;\n    this.thisArg = thisArg;\n    this.count = 0;\n  }\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  FilterSubscriber.prototype._next = function (value) {\n    var result;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  };\n  return FilterSubscriber;\n}(Subscriber_1.Subscriber);","map":{"version":3,"mappings":";;;;;;;;;AACA,2BAA2B,eAAe,CAAC;AAU3C;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA,gBAA0BA,SAA+C,EAC/CC,OAAa;EACrC,OAAO,gCAAgCC,MAAqB;IAC1D,OAAOA,MAAM,CAACC,IAAI,CAAC,IAAIC,cAAc,CAACJ,SAAS,EAAEC,OAAO,CAAC,CAAC;EAC5D,CAAC;AACH;AALgBI,cAAM,SAKrB;AAED;EACE,wBAAoBL,SAA+C,EAC/CC,OAAa;IADb,cAAS,GAATD,SAAS;IACT,YAAO,GAAPC,OAAO;EAC3B;EAEAG,6BAAI,GAAJ,UAAKE,UAAyB,EAAEJ,MAAW;IACzC,OAAOA,MAAM,CAACK,SAAS,CAAC,IAAIC,gBAAgB,CAACF,UAAU,EAAE,IAAI,CAACN,SAAS,EAAE,IAAI,CAACC,OAAO,CAAC,CAAC;EACzF,CAAC;EACH,qBAAC;AAAD,CAAC,EARD;AAUA;;;;;AAKA;EAAkCQ;EAIhC,0BAAYC,WAA0B,EAClBV,SAA+C,EAC/CC,OAAY;IAC9BU,kBAAMD,WAAW,CAAC;IAFA,cAAS,GAATV,SAAS;IACT,YAAO,GAAPC,OAAO;IAJ3B,UAAK,GAAW,CAAC;EAMjB;EAEA;EACA;EACUO,gCAAK,GAAf,UAAgBI,KAAQ;IACtB,IAAIC,MAAW;IACf,IAAI;MACFA,MAAM,GAAG,IAAI,CAACb,SAAS,CAACc,IAAI,CAAC,IAAI,CAACb,OAAO,EAAEW,KAAK,EAAE,IAAI,CAACG,KAAK,EAAE,CAAC;IACjE,CAAE,QAAOC,GAAG,EAAE;MACZ,IAAI,CAACN,WAAW,CAACO,KAAK,CAACD,GAAG,CAAC;MAC3B;IACF;IACA,IAAIH,MAAM,EAAE;MACV,IAAI,CAACH,WAAW,CAACQ,IAAI,CAACN,KAAK,CAAC;IAC9B;EACF,CAAC;EACH,uBAAC;AAAD,CAAC,CAxBiCO,uBAAU","names":["predicate","thisArg","source","lift","FilterOperator","exports","subscriber","subscribe","FilterSubscriber","__extends","destination","_super","value","result","call","count","err","error","next","Subscriber_1"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\src\\operators\\filter.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): OperatorFunction<T, S>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T> {\n  return function filterOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nclass FilterOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean,\n              private thisArg?: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FilterSubscriber<T> extends Subscriber<T> {\n\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean,\n              private thisArg: any) {\n    super(destination);\n  }\n\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}