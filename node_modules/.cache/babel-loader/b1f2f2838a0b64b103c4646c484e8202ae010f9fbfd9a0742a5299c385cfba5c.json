{"ast":null,"code":"\"use strict\";\n\n/**\n * @module botframework-streaming\n */\n/**\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar headerSerializer_1 = require(\"../payloads/headerSerializer\");\nvar payloadConstants_1 = require(\"../payloads/payloadConstants\");\nvar transportDisconnectedEvent_1 = require(\"./transportDisconnectedEvent\");\n/**\n * Streaming payload sender.\n */\nvar PayloadSender = /** @class */function () {\n  function PayloadSender() {}\n  Object.defineProperty(PayloadSender.prototype, \"isConnected\", {\n    /**\n     * Tests whether the transport sender is connected.\n     *\n     * @returns true if connected to a transport sender.\n     */\n    get: function () {\n      return !!this.sender;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Connects to the given transport sender.\n   *\n   * @param sender The transport sender to connect this payload sender to.\n   */\n  PayloadSender.prototype.connect = function (sender) {\n    this.sender = sender;\n  };\n  /**\n   * Sends a payload out over the connected transport sender.\n   *\n   * @param header The header to attach to the outgoing payload.\n   * @param payload The stream of buffered data to send.\n   * @param sentCalback The function to execute when the send has completed.\n   */\n  PayloadSender.prototype.sendPayload = function (header, payload, sentCallback) {\n    var packet = {\n      header: header,\n      payload: payload,\n      sentCallback: sentCallback\n    };\n    this.writePacket(packet);\n  };\n  /**\n   * Disconnects this payload sender.\n   *\n   * @param e The disconnected event arguments to include in the disconnected event broadcast.\n   */\n  PayloadSender.prototype.disconnect = function (e) {\n    if (this.isConnected) {\n      this.sender.close();\n      this.sender = null;\n      if (this.disconnected) {\n        this.disconnected(this, e || transportDisconnectedEvent_1.TransportDisconnectedEvent.Empty);\n      }\n    }\n  };\n  PayloadSender.prototype.writePacket = function (packet) {\n    try {\n      if (packet.header.payloadLength > 0 && packet.payload) {\n        var leftOver = packet.header.payloadLength;\n        while (leftOver > 0) {\n          var count = leftOver <= payloadConstants_1.PayloadConstants.MaxPayloadLength ? leftOver : payloadConstants_1.PayloadConstants.MaxPayloadLength;\n          var chunk = packet.payload.read(count);\n          var header = packet.header;\n          header.payloadLength = count;\n          header.end = leftOver <= payloadConstants_1.PayloadConstants.MaxPayloadLength;\n          var sendHeaderBuffer = Buffer.alloc(payloadConstants_1.PayloadConstants.MaxHeaderLength);\n          headerSerializer_1.HeaderSerializer.serialize(header, sendHeaderBuffer);\n          this.sender.send(sendHeaderBuffer);\n          this.sender.send(chunk);\n          leftOver -= chunk.length;\n        }\n        if (packet.sentCallback) {\n          packet.sentCallback();\n        }\n      }\n    } catch (e) {\n      this.disconnect(new transportDisconnectedEvent_1.TransportDisconnectedEvent(e.message));\n    }\n  };\n  return PayloadSender;\n}();\nexports.PayloadSender = PayloadSender;","map":{"version":3,"mappings":";;AAAA;;;AAGA;;;;;;;AAKA;AAEA;AACA;AAMA;;;AAGA;EAAA,0BAkFA;EAzEIA,sBAAWC,sCAAW;IALtB;;;;;SAKA;MACI,OAAO,CAAC,CAAC,IAAI,CAACC,MAAM;IACxB,CAAC;;;;EAED;;;;;EAKOD,+BAAO,GAAd,UAAeC,MAAwB;IACnC,IAAI,CAACA,MAAM,GAAGA,MAAM;EACxB,CAAC;EAED;;;;;;;EAOOD,mCAAW,GAAlB,UAAmBE,MAAe,EAAEC,OAA4B,EAAEC,YAAkC;IAChG,IAAIC,MAAM,GAAgB;MAACH,MAAM;MAAEC,OAAO;MAAEC,YAAY;IAAA,CAAC;IACzD,IAAI,CAACE,WAAW,CAACD,MAAM,CAAC;EAC5B,CAAC;EAED;;;;;EAKOL,kCAAU,GAAjB,UAAkBO,CAA8B;IAC5C,IAAI,IAAI,CAACC,WAAW,EAAE;MAClB,IAAI,CAACP,MAAM,CAACQ,KAAK,EAAE;MACnB,IAAI,CAACR,MAAM,GAAG,IAAI;MAElB,IAAI,IAAI,CAACS,YAAY,EAAE;QACnB,IAAI,CAACA,YAAY,CAAC,IAAI,EAAEH,CAAC,IAAII,uDAA0B,CAACC,KAAK,CAAC;;;EAG1E,CAAC;EAEOZ,mCAAW,GAAnB,UAAoBK,MAAmB;IACnC,IAAI;MACA,IAAIA,MAAM,CAACH,MAAM,CAACW,aAAa,GAAG,CAAC,IAAIR,MAAM,CAACF,OAAO,EAAE;QAEnD,IAAIW,QAAQ,GAAGT,MAAM,CAACH,MAAM,CAACW,aAAa;QAE1C,OAAOC,QAAQ,GAAG,CAAC,EAAE;UACjB,IAAIC,KAAK,GAAGD,QAAQ,IAAIE,mCAAgB,CAACC,gBAAgB,GAAGH,QAAQ,GAAGE,mCAAgB,CAACC,gBAAgB;UACxG,IAAIC,KAAK,GAAGb,MAAM,CAACF,OAAO,CAACgB,IAAI,CAACJ,KAAK,CAAC;UAEtC,IAAIb,MAAM,GAAGG,MAAM,CAACH,MAAM;UAC1BA,MAAM,CAACW,aAAa,GAAGE,KAAK;UAC5Bb,MAAM,CAACkB,GAAG,GAAGN,QAAQ,IAAIE,mCAAgB,CAACC,gBAAgB;UAE1D,IAAII,gBAAgB,GAAWC,MAAM,CAACC,KAAK,CAACP,mCAAgB,CAACQ,eAAe,CAAC;UAE7EC,mCAAgB,CAACC,SAAS,CAACxB,MAAM,EAAEmB,gBAAgB,CAAC;UAEpD,IAAI,CAACpB,MAAM,CAAC0B,IAAI,CAACN,gBAAgB,CAAC;UAElC,IAAI,CAACpB,MAAM,CAAC0B,IAAI,CAACT,KAAK,CAAC;UACvBJ,QAAQ,IAAGI,KAAK,CAACU,MAAM;;QAG3B,IAAIvB,MAAM,CAACD,YAAY,EAAE;UACrBC,MAAM,CAACD,YAAY,EAAE;;;KAGhC,CAAC,OAAOG,CAAC,EAAE;MACR,IAAI,CAACsB,UAAU,CAAC,IAAIlB,uDAA0B,CAACJ,CAAC,CAACuB,OAAO,CAAC,CAAC;;EAElE,CAAC;EACL,oBAAC;AAAD,CAAC,EAlFD;AAAaC","names":["Object","PayloadSender","sender","header","payload","sentCallback","packet","writePacket","e","isConnected","close","disconnected","transportDisconnectedEvent_1","Empty","payloadLength","leftOver","count","payloadConstants_1","MaxPayloadLength","chunk","read","end","sendHeaderBuffer","Buffer","alloc","MaxHeaderLength","headerSerializer_1","serialize","send","length","disconnect","message","exports"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\botframework-streaming\\src\\payloadTransport\\payloadSender.ts"],"sourcesContent":["/**\r\n * @module botframework-streaming\r\n */\r\n/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { HeaderSerializer } from '../payloads/headerSerializer';\r\nimport { SubscribableStream } from '../subscribableStream';\r\nimport { PayloadConstants } from '../payloads/payloadConstants';\r\nimport { TransportDisconnectedEvent } from './transportDisconnectedEvent';\r\nimport { TransportDisconnectedEventHandler } from './transportDisconnectedEventHandler';\r\nimport { ITransportSender } from '../interfaces/ITransportSender';\r\nimport { IHeader } from '../interfaces/IHeader';\r\nimport { ISendPacket } from '../interfaces/ISendPacket';\r\n\r\n/**\r\n * Streaming payload sender.\r\n */\r\nexport class PayloadSender {\r\n    public disconnected?: TransportDisconnectedEventHandler;\r\n    private sender: ITransportSender;\r\n\r\n    /**\r\n     * Tests whether the transport sender is connected.\r\n     *\r\n     * @returns true if connected to a transport sender.\r\n     */\r\n    public get isConnected(): boolean {\r\n        return !!this.sender;\r\n    }\r\n\r\n    /**\r\n     * Connects to the given transport sender.\r\n     *\r\n     * @param sender The transport sender to connect this payload sender to.\r\n     */\r\n    public connect(sender: ITransportSender): void {\r\n        this.sender = sender;\r\n    }\r\n\r\n    /**\r\n     * Sends a payload out over the connected transport sender.\r\n     *\r\n     * @param header The header to attach to the outgoing payload.\r\n     * @param payload The stream of buffered data to send.\r\n     * @param sentCalback The function to execute when the send has completed.\r\n     */\r\n    public sendPayload(header: IHeader, payload?: SubscribableStream, sentCallback?: () => Promise<void>): void {\r\n        var packet: ISendPacket = {header, payload, sentCallback};\r\n        this.writePacket(packet);\r\n    }\r\n\r\n    /**\r\n     * Disconnects this payload sender.\r\n     *\r\n     * @param e The disconnected event arguments to include in the disconnected event broadcast.\r\n     */\r\n    public disconnect(e?: TransportDisconnectedEvent): void {\r\n        if (this.isConnected) {\r\n            this.sender.close();\r\n            this.sender = null;\r\n\r\n            if (this.disconnected) {\r\n                this.disconnected(this, e || TransportDisconnectedEvent.Empty);\r\n            }\r\n        }\r\n    }\r\n\r\n    private writePacket(packet: ISendPacket): void {\r\n        try {\r\n            if (packet.header.payloadLength > 0 && packet.payload) {\r\n\r\n                let leftOver = packet.header.payloadLength;\r\n\r\n                while (leftOver > 0) {                   \r\n                    let count = leftOver <= PayloadConstants.MaxPayloadLength ? leftOver : PayloadConstants.MaxPayloadLength;\r\n                    let chunk = packet.payload.read(count);\r\n\r\n                    var header = packet.header;\r\n                    header.payloadLength = count;\r\n                    header.end = leftOver <= PayloadConstants.MaxPayloadLength;\r\n\r\n                    let sendHeaderBuffer: Buffer = Buffer.alloc(PayloadConstants.MaxHeaderLength);\r\n\r\n                    HeaderSerializer.serialize(header, sendHeaderBuffer);\r\n\r\n                    this.sender.send(sendHeaderBuffer);\r\n\r\n                    this.sender.send(chunk);\r\n                    leftOver-= chunk.length;\r\n                }\r\n\r\n                if (packet.sentCallback) {\r\n                    packet.sentCallback();\r\n                }\r\n            }\r\n        } catch (e) {\r\n            this.disconnect(new TransportDisconnectedEvent(e.message));\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}