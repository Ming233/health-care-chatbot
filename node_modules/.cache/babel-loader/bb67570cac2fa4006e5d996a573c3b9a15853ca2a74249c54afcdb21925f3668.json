{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Web socket based transport.\n */\nvar WebSocketTransport = /** @class */function () {\n  /**\n   * Creates a new instance of the [WebSocketTransport](xref:botframework-streaming.WebSocketTransport) class.\n   *\n   * @param ws The ISocket to build this transport on top of.\n   */\n  function WebSocketTransport(ws) {\n    var _this = this;\n    this._socket = ws;\n    this._queue = [];\n    this._activeOffset = 0;\n    this._activeReceiveCount = 0;\n    this._socket.setOnMessageHandler(function (data) {\n      _this.onReceive(data);\n    });\n    this._socket.setOnErrorHandler(function (err) {\n      _this.onError(err);\n    });\n    this._socket.setOnCloseHandler(function () {\n      _this.onClose();\n    });\n  }\n  /**\n   * Sends the given buffer out over the socket's connection.\n   *\n   * @param buffer The buffered data to send out over the connection.\n   */\n  WebSocketTransport.prototype.send = function (buffer) {\n    if (this._socket && this._socket.isConnected) {\n      this._socket.write(buffer);\n      return buffer.length;\n    }\n    return 0;\n  };\n  Object.defineProperty(WebSocketTransport.prototype, \"isConnected\", {\n    /**\n     * Returns true if the transport is connected to a socket.\n     */\n    get: function () {\n      return this._socket.isConnected;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Close the socket this transport is connected to.\n   */\n  WebSocketTransport.prototype.close = function () {\n    if (this._socket && this._socket.isConnected) {\n      this._socket.close();\n    }\n  };\n  /**\n   * Attempt to receive incoming data from the connected socket.\n   *\n   * @param count The number of bytes to attempt to receive.\n   * @returns A buffer populated with the received data.\n   */\n  WebSocketTransport.prototype.receive = function (count) {\n    return __awaiter(this, void 0, void 0, function () {\n      var promise;\n      var _this = this;\n      return __generator(this, function (_a) {\n        if (this._activeReceiveResolve) {\n          throw new Error('Cannot call receive more than once before it has returned.');\n        }\n        this._activeReceiveCount = count;\n        promise = new Promise(function (resolve, reject) {\n          _this._activeReceiveResolve = resolve;\n          _this._activeReceiveReject = reject;\n        });\n        this.trySignalData();\n        return [2 /*return*/, promise];\n      });\n    });\n  };\n  /**\n   * Sets the transport to attempt to receive incoming data that has not yet arrived.\n   *\n   * @param data A buffer to store incoming data in.\n   */\n  WebSocketTransport.prototype.onReceive = function (data) {\n    if (this._queue && data && data.byteLength > 0) {\n      this._queue.push(Buffer.from(data));\n      this.trySignalData();\n    }\n  };\n  WebSocketTransport.prototype.onClose = function () {\n    if (this._activeReceiveReject) {\n      this._activeReceiveReject(new Error('Socket was closed.'));\n    }\n    this._active = null;\n    this._activeOffset = 0;\n    this._activeReceiveResolve = null;\n    this._activeReceiveReject = null;\n    this._activeReceiveCount = 0;\n    this._socket = null;\n  };\n  WebSocketTransport.prototype.onError = function (err) {\n    if (this._activeReceiveReject) {\n      this._activeReceiveReject(err);\n    }\n    this.onClose();\n  };\n  WebSocketTransport.prototype.trySignalData = function () {\n    if (this._activeReceiveResolve) {\n      if (!this._active && this._queue.length > 0) {\n        this._active = this._queue.shift();\n        this._activeOffset = 0;\n      }\n      if (this._active) {\n        if (this._activeOffset === 0 && this._active.length === this._activeReceiveCount) {\n          // can send the entire _active buffer\n          var buffer = this._active;\n          this._active = null;\n          this._activeReceiveResolve(buffer);\n        } else {\n          // create a Buffer.from and copy some of the contents into it\n          var available = Math.min(this._activeReceiveCount, this._active.length - this._activeOffset);\n          var buffer = Buffer.alloc(available);\n          this._active.copy(buffer, 0, this._activeOffset, this._activeOffset + available);\n          this._activeOffset += available;\n          // if we used all of active, set it to undefined\n          if (this._activeOffset >= this._active.length) {\n            this._active = null;\n            this._activeOffset = 0;\n          }\n          this._activeReceiveResolve(buffer);\n        }\n        this._activeReceiveCount = 0;\n        this._activeReceiveReject = null;\n        this._activeReceiveResolve = null;\n      }\n    }\n  };\n  return WebSocketTransport;\n}();\nexports.WebSocketTransport = WebSocketTransport;","map":{"version":3,"mappings":"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","names":["ws","_socket","_queue","_activeOffset","_activeReceiveCount","setOnMessageHandler","data","_this","onReceive","setOnErrorHandler","err","onError","setOnCloseHandler","onClose","WebSocketTransport","buffer","isConnected","write","length","Object","close","count","_activeReceiveResolve","Error","promise","Promise","resolve","reject","_activeReceiveReject","trySignalData","byteLength","push","Buffer","from","_active","shift","available","Math","min","alloc","copy","exports"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\botframework-streaming\\src\\webSocket\\webSocketTransport.ts"],"sourcesContent":["/**\r\n * @module botframework-streaming\r\n */\r\n/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { INodeBuffer } from '../interfaces/INodeBuffer';\r\nimport { ISocket } from '../interfaces/ISocket';\r\nimport { ITransportSender } from '../interfaces/ITransportSender';\r\nimport { ITransportReceiver } from '../interfaces/ITransportReceiver';\r\n\r\n/**\r\n * Web socket based transport.\r\n */\r\nexport class WebSocketTransport implements ITransportSender, ITransportReceiver {\r\n    private _socket: ISocket;\r\n    private readonly _queue: INodeBuffer[];\r\n    private _active: INodeBuffer;\r\n    private _activeOffset: number;\r\n    private _activeReceiveResolve: (resolve: INodeBuffer) => void;\r\n    private _activeReceiveReject: (reason?: any) => void;\r\n    private _activeReceiveCount: number;\r\n\r\n    /**\r\n     * Creates a new instance of the [WebSocketTransport](xref:botframework-streaming.WebSocketTransport) class.\r\n     *\r\n     * @param ws The ISocket to build this transport on top of.\r\n     */\r\n    public constructor(ws: ISocket) {\r\n        this._socket = ws;\r\n        this._queue = [];\r\n        this._activeOffset = 0;\r\n        this._activeReceiveCount = 0;\r\n        this._socket.setOnMessageHandler((data): void => {\r\n            this.onReceive(data);\r\n        });\r\n        this._socket.setOnErrorHandler((err): void => {\r\n            this.onError(err);\r\n        });\r\n        this._socket.setOnCloseHandler((): void => {\r\n            this.onClose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sends the given buffer out over the socket's connection.\r\n     *\r\n     * @param buffer The buffered data to send out over the connection.\r\n     */\r\n    public send(buffer: INodeBuffer): number {\r\n        if (this._socket && this._socket.isConnected) {\r\n            this._socket.write(buffer);\r\n\r\n            return buffer.length;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the transport is connected to a socket.\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this._socket.isConnected;\r\n    }\r\n\r\n    /**\r\n     * Close the socket this transport is connected to.\r\n     */\r\n    public close(): void {\r\n        if (this._socket && this._socket.isConnected) {\r\n            this._socket.close();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attempt to receive incoming data from the connected socket.\r\n     *\r\n     * @param count The number of bytes to attempt to receive.\r\n     * @returns A buffer populated with the received data.\r\n     */\r\n    public async receive(count: number): Promise<INodeBuffer> {\r\n        if (this._activeReceiveResolve) {\r\n            throw new Error('Cannot call receive more than once before it has returned.');\r\n        }\r\n\r\n        this._activeReceiveCount = count;\r\n\r\n        let promise = new Promise<INodeBuffer>((resolve, reject): void => {\r\n            this._activeReceiveResolve = resolve;\r\n            this._activeReceiveReject = reject;\r\n        });\r\n\r\n        this.trySignalData();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Sets the transport to attempt to receive incoming data that has not yet arrived.\r\n     *\r\n     * @param data A buffer to store incoming data in.\r\n     */\r\n    public onReceive(data: INodeBuffer): void {\r\n        if (this._queue && data && data.byteLength > 0) {\r\n            this._queue.push(Buffer.from(data));\r\n            this.trySignalData();\r\n        }\r\n    }\r\n\r\n    private onClose(): void {\r\n        if (this._activeReceiveReject) {\r\n            this._activeReceiveReject(new Error('Socket was closed.'));\r\n        }\r\n\r\n        this._active = null;\r\n        this._activeOffset = 0;\r\n        this._activeReceiveResolve = null;\r\n        this._activeReceiveReject = null;\r\n        this._activeReceiveCount = 0;\r\n        this._socket = null;\r\n    }\r\n\r\n    private onError(err: Error): void {\r\n        if (this._activeReceiveReject) {\r\n            this._activeReceiveReject(err);\r\n        }\r\n        this.onClose();\r\n    }\r\n\r\n    private trySignalData(): void {\r\n        if (this._activeReceiveResolve) {\r\n            if (!this._active && this._queue.length > 0) {\r\n                this._active = this._queue.shift();\r\n                this._activeOffset = 0;\r\n            }\r\n\r\n            if (this._active) {\r\n                if (this._activeOffset === 0 && this._active.length === this._activeReceiveCount) {\r\n                    // can send the entire _active buffer\r\n                    let buffer = this._active;\r\n                    this._active = null;\r\n\r\n                    this._activeReceiveResolve(buffer);\r\n                } else {\r\n                    // create a Buffer.from and copy some of the contents into it\r\n                    let available = Math.min(this._activeReceiveCount, this._active.length - this._activeOffset);\r\n                    let buffer = Buffer.alloc(available);\r\n                    this._active.copy(buffer, 0, this._activeOffset, this._activeOffset + available);\r\n                    this._activeOffset += available;\r\n\r\n                    // if we used all of active, set it to undefined\r\n                    if (this._activeOffset >= this._active.length) {\r\n                        this._active = null;\r\n                        this._activeOffset = 0;\r\n                    }\r\n\r\n                    this._activeReceiveResolve(buffer);\r\n                }\r\n\r\n                this._activeReceiveCount = 0;\r\n                this._activeReceiveReject = null;\r\n                this._activeReceiveResolve = null;\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}