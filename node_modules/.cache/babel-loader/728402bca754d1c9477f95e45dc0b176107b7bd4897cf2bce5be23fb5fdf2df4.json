{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar isArray_1 = require('../util/isArray');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar none = {};\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n  var observables = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n  var project = null;\n  if (typeof observables[observables.length - 1] === 'function') {\n    project = observables.pop();\n  }\n  // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n  if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n    observables = observables[0].slice();\n  }\n  return function (source) {\n    return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project));\n  };\n}\nexports.combineLatest = combineLatest;\nvar CombineLatestOperator = function () {\n  function CombineLatestOperator(project) {\n    this.project = project;\n  }\n  CombineLatestOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n  };\n  return CombineLatestOperator;\n}();\nexports.CombineLatestOperator = CombineLatestOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CombineLatestSubscriber = function (_super) {\n  __extends(CombineLatestSubscriber, _super);\n  function CombineLatestSubscriber(destination, project) {\n    _super.call(this, destination);\n    this.project = project;\n    this.active = 0;\n    this.values = [];\n    this.observables = [];\n  }\n  CombineLatestSubscriber.prototype._next = function (observable) {\n    this.values.push(none);\n    this.observables.push(observable);\n  };\n  CombineLatestSubscriber.prototype._complete = function () {\n    var observables = this.observables;\n    var len = observables.length;\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      this.active = len;\n      this.toRespond = len;\n      for (var i = 0; i < len; i++) {\n        var observable = observables[i];\n        this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n      }\n    }\n  };\n  CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n    if ((this.active -= 1) === 0) {\n      this.destination.complete();\n    }\n  };\n  CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var values = this.values;\n    var oldVal = values[outerIndex];\n    var toRespond = !this.toRespond ? 0 : oldVal === none ? --this.toRespond : this.toRespond;\n    values[outerIndex] = innerValue;\n    if (toRespond === 0) {\n      if (this.project) {\n        this._tryProject(values);\n      } else {\n        this.destination.next(values.slice());\n      }\n    }\n  };\n  CombineLatestSubscriber.prototype._tryProject = function (values) {\n    var result;\n    try {\n      result = this.project.apply(this, values);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  };\n  return CombineLatestSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\nexports.CombineLatestSubscriber = CombineLatestSubscriber;","map":{"version":3,"mappings":"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","names":["none","observables","project","length","pop","isArray_1","slice","source","lift","call","ArrayObservable_1","CombineLatestOperator","exports","subscriber","subscribe","CombineLatestSubscriber","__extends","destination","_super","observable","values","push","len","complete","active","toRespond","i","add","subscribeToResult_1","unused","outerValue","innerValue","outerIndex","innerIndex","innerSub","oldVal","_tryProject","next","result","apply","err","error","OuterSubscriber_1"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\src\\operators\\combineLatest.ts"],"sourcesContent":["import { Observable, ObservableInput } from '../Observable';\nimport { ArrayObservable } from '../observable/ArrayObservable';\nimport { isArray } from '../util/isArray';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\nconst none = {};\n\n/* tslint:disable:max-line-length */\nexport function combineLatest<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\nexport function combineLatest<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\nexport function combineLatest<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\nexport function combineLatest<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\nexport function combineLatest<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\nexport function combineLatest<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\nexport function combineLatest<T, R>(array: ObservableInput<T>[]): OperatorFunction<T, Array<T>>;\nexport function combineLatest<T, TOther, R>(array: ObservableInput<TOther>[], project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<any> |\n                                                    Array<ObservableInput<any>> |\n                                                    ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  let project: (...values: Array<any>) => R = null;\n  if (typeof observables[observables.length - 1] === 'function') {\n    project = <(...values: Array<any>) => R>observables.pop();\n  }\n\n  // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n  if (observables.length === 1 && isArray(observables[0])) {\n    observables = (<any>observables[0]).slice();\n  }\n\n  return (source: Observable<T>) => source.lift.call(new ArrayObservable([source, ...observables]), new CombineLatestOperator(project));\n}\n\nexport class CombineLatestOperator<T, R> implements Operator<T, R> {\n  constructor(private project?: (...values: Array<any>) => R) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private active: number = 0;\n  private values: any[] = [];\n  private observables: any[] = [];\n  private toRespond: number;\n\n  constructor(destination: Subscriber<R>, private project?: (...values: Array<any>) => R) {\n    super(destination);\n  }\n\n  protected _next(observable: any) {\n    this.values.push(none);\n    this.observables.push(observable);\n  }\n\n  protected _complete() {\n    const observables = this.observables;\n    const len = observables.length;\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      this.active = len;\n      this.toRespond = len;\n      for (let i = 0; i < len; i++) {\n        const observable = observables[i];\n        this.add(subscribeToResult(this, observable, observable, i));\n      }\n    }\n  }\n\n  notifyComplete(unused: Subscriber<R>): void {\n    if ((this.active -= 1) === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    const values = this.values;\n    const oldVal = values[outerIndex];\n    const toRespond = !this.toRespond\n      ? 0\n      : oldVal === none ? --this.toRespond : this.toRespond;\n    values[outerIndex] = innerValue;\n\n    if (toRespond === 0) {\n      if (this.project) {\n        this._tryProject(values);\n      } else {\n        this.destination.next(values.slice());\n      }\n    }\n  }\n\n  private _tryProject(values: any[]) {\n    let result: any;\n    try {\n      result = this.project.apply(this, values);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}