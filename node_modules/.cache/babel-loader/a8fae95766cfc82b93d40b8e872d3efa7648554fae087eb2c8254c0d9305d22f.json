{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar payloadConstants_1 = require(\"./payloadConstants\");\n/**\n * Streaming header serializer\n */\nvar HeaderSerializer = /** @class */function () {\n  function HeaderSerializer() {}\n  /**\n   * Serializes the header into a buffer\n   *\n   * @param header The header to serialize.\n   * @param buffer The buffer into which to serialize the header.\n   */\n  HeaderSerializer.serialize = function (header, buffer) {\n    buffer.write(header.payloadType, this.TypeOffset, 1, this.Encoding);\n    buffer.write(this.Delimiter, this.TypeDelimiterOffset, 1, this.Encoding);\n    buffer.write(this.headerLengthPadder(header.payloadLength, this.LengthLength, '0'), this.LengthOffset, this.LengthLength, this.Encoding);\n    buffer.write(this.Delimiter, this.LengthDelimeterOffset, 1, this.Encoding);\n    buffer.write(header.id, this.IdOffset);\n    buffer.write(this.Delimiter, this.IdDelimeterOffset, 1, this.Encoding);\n    buffer.write(header.end ? this.End : this.NotEnd, this.EndOffset);\n    buffer.write(this.Terminator, this.TerminatorOffset);\n  };\n  /**\n   * Deserializes a buffer containing header information.\n   *\n   * @param buffer The buffer from which to obtain the data to deserialize.\n   * @returns The deserialized header from the buffer.\n   */\n  HeaderSerializer.deserialize = function (buffer) {\n    var jsonBuffer = buffer.toString(this.Encoding);\n    var headerArray = jsonBuffer.split(this.Delimiter);\n    if (headerArray.length !== 4) {\n      throw Error(\"Cannot parse header, header is malformed. Header: \" + jsonBuffer);\n    }\n    var payloadType = headerArray[0],\n      length = headerArray[1],\n      id = headerArray[2],\n      headerEnd = headerArray[3];\n    var end = headerEnd === '1\\n';\n    var payloadLength = Number(length);\n    var header = {\n      end: end,\n      payloadLength: payloadLength,\n      payloadType: payloadType,\n      id: id\n    };\n    if (!(header.payloadLength <= payloadConstants_1.PayloadConstants.MaxPayloadLength && header.payloadLength >= payloadConstants_1.PayloadConstants.MinLength)) {\n      throw Error(\"Header length of \" + header.payloadLength + \" is missing or malformed\");\n    }\n    if (header.payloadType.length !== this.TypeDelimiterOffset) {\n      throw Error(\"Header type '\" + header.payloadType.length + \"' is missing or malformed.\");\n    }\n    if (!header.id || !header.id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) || header.id.length !== this.IdLength) {\n      throw Error(\"Header ID '\" + header.id + \"' is missing or malformed.\");\n    }\n    if (!(headerEnd === '0\\n' || headerEnd === '1\\n')) {\n      throw Error(\"Header End is missing or not a valid value. Header end: '\" + headerEnd + \"'\");\n    }\n    return header;\n  };\n  HeaderSerializer.headerLengthPadder = function (lengthValue, totalLength, padChar) {\n    var result = Array(totalLength + 1).join(padChar);\n    var lengthString = lengthValue.toString();\n    return (result + lengthString).slice(lengthString.length);\n  };\n  HeaderSerializer.Delimiter = '.';\n  HeaderSerializer.Terminator = '\\n';\n  HeaderSerializer.End = '1';\n  HeaderSerializer.NotEnd = '0';\n  HeaderSerializer.TypeOffset = 0;\n  HeaderSerializer.TypeDelimiterOffset = 1;\n  HeaderSerializer.LengthOffset = 2;\n  HeaderSerializer.LengthLength = 6;\n  HeaderSerializer.LengthDelimeterOffset = 8;\n  HeaderSerializer.IdOffset = 9;\n  HeaderSerializer.IdLength = 36;\n  HeaderSerializer.IdDelimeterOffset = 45;\n  HeaderSerializer.EndOffset = 46;\n  HeaderSerializer.TerminatorOffset = 47;\n  HeaderSerializer.Encoding = 'utf8';\n  return HeaderSerializer;\n}();\nexports.HeaderSerializer = HeaderSerializer;","map":{"version":3,"mappings":"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","names":["HeaderSerializer","header","buffer","write","payloadType","TypeOffset","Encoding","Delimiter","TypeDelimiterOffset","headerLengthPadder","payloadLength","LengthLength","LengthOffset","LengthDelimeterOffset","id","IdOffset","IdDelimeterOffset","end","End","NotEnd","EndOffset","Terminator","TerminatorOffset","jsonBuffer","toString","headerArray","split","length","Error","headerEnd","Number","payloadConstants_1","MaxPayloadLength","MinLength","match","IdLength","lengthValue","totalLength","padChar","result","Array","join","lengthString","slice","exports"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\botframework-streaming\\src\\payloads\\headerSerializer.ts"],"sourcesContent":["/**\r\n * @module botframework-streaming\r\n */\r\n/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { IHeader } from '../interfaces/IHeader';\r\nimport { PayloadConstants } from './payloadConstants';\r\nimport { INodeBuffer } from '../interfaces/INodeBuffer';\r\n\r\n/**\r\n * Streaming header serializer\r\n */\r\nexport class HeaderSerializer {\r\n    public static readonly Delimiter = '.';\r\n    public static readonly Terminator = '\\n';\r\n    public static readonly End = '1';\r\n    public static readonly NotEnd = '0';\r\n    public static readonly TypeOffset: number = 0;\r\n    public static readonly TypeDelimiterOffset = 1;\r\n    public static readonly LengthOffset = 2;\r\n    public static readonly LengthLength = 6;\r\n    public static readonly LengthDelimeterOffset = 8;\r\n    public static readonly IdOffset = 9;\r\n    public static readonly IdLength = 36;\r\n    public static readonly IdDelimeterOffset = 45;\r\n    public static readonly EndOffset = 46;\r\n    public static readonly TerminatorOffset = 47;\r\n    public static readonly Encoding = 'utf8';\r\n\r\n    /**\r\n     * Serializes the header into a buffer\r\n     *\r\n     * @param header The header to serialize.\r\n     * @param buffer The buffer into which to serialize the header.\r\n     */\r\n    public static serialize(header: IHeader, buffer: INodeBuffer): void {\r\n        buffer.write(header.payloadType, this.TypeOffset, 1,  this.Encoding);\r\n        buffer.write(this.Delimiter, this.TypeDelimiterOffset, 1, this.Encoding);\r\n        buffer.write(this.headerLengthPadder(header.payloadLength, this.LengthLength, '0'), this.LengthOffset, this.LengthLength, this.Encoding);\r\n        buffer.write(this.Delimiter, this.LengthDelimeterOffset, 1, this.Encoding);\r\n        buffer.write(header.id, this.IdOffset);\r\n        buffer.write(this.Delimiter, this.IdDelimeterOffset, 1, this.Encoding);\r\n        buffer.write(header.end ? this.End : this.NotEnd, this.EndOffset);\r\n        buffer.write(this.Terminator, this.TerminatorOffset);\r\n    }\r\n\r\n    /**\r\n     * Deserializes a buffer containing header information.\r\n     *\r\n     * @param buffer The buffer from which to obtain the data to deserialize.\r\n     * @returns The deserialized header from the buffer.\r\n     */\r\n    public static deserialize(buffer: INodeBuffer): IHeader {\r\n        let jsonBuffer = buffer.toString(this.Encoding);\r\n        let headerArray = jsonBuffer.split(this.Delimiter);\r\n\r\n        if (headerArray.length !== 4) {\r\n            throw Error(`Cannot parse header, header is malformed. Header: ${ jsonBuffer }`);\r\n        }\r\n\r\n        const [payloadType, length, id, headerEnd] = headerArray;\r\n\r\n        const end = headerEnd === '1\\n';\r\n        const payloadLength = Number(length);\r\n        \r\n        const header: IHeader = { end, payloadLength, payloadType, id };\r\n\r\n        if (!(header.payloadLength <= PayloadConstants.MaxPayloadLength && header.payloadLength >= PayloadConstants.MinLength)) {\r\n            throw Error(`Header length of ${ header.payloadLength } is missing or malformed`);\r\n        }\r\n\r\n        if (header.payloadType.length !== this.TypeDelimiterOffset) {\r\n            throw Error(`Header type '${ header.payloadType.length }' is missing or malformed.`);\r\n        }\r\n\r\n        if (!header.id || !header.id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) || header.id.length !==  this.IdLength) {\r\n            throw Error(`Header ID '${ header.id }' is missing or malformed.`);\r\n        }\r\n\r\n        if (!(headerEnd === '0\\n' || headerEnd === '1\\n')) {\r\n            throw Error(`Header End is missing or not a valid value. Header end: '${ headerEnd }'`);\r\n        }\r\n\r\n        return header;\r\n    }\r\n\r\n    public static headerLengthPadder(lengthValue: number, totalLength: number, padChar: string): string {\r\n        let result = Array(totalLength + 1)\r\n            .join(padChar);\r\n\r\n        let lengthString = lengthValue.toString();\r\n\r\n        return (result + lengthString).slice(lengthString.length);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}