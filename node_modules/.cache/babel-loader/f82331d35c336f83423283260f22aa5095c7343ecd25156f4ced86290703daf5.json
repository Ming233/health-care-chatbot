{"ast":null,"code":"\"use strict\";\n\nvar ConnectableObservable_1 = require('../observable/ConnectableObservable');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nfunction multicast(subjectOrSubjectFactory, selector) {\n  return function multicastOperatorFunction(source) {\n    var subjectFactory;\n    if (typeof subjectOrSubjectFactory === 'function') {\n      subjectFactory = subjectOrSubjectFactory;\n    } else {\n      subjectFactory = function subjectFactory() {\n        return subjectOrSubjectFactory;\n      };\n    }\n    if (typeof selector === 'function') {\n      return source.lift(new MulticastOperator(subjectFactory, selector));\n    }\n    var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);\n    connectable.source = source;\n    connectable.subjectFactory = subjectFactory;\n    return connectable;\n  };\n}\nexports.multicast = multicast;\nvar MulticastOperator = function () {\n  function MulticastOperator(subjectFactory, selector) {\n    this.subjectFactory = subjectFactory;\n    this.selector = selector;\n  }\n  MulticastOperator.prototype.call = function (subscriber, source) {\n    var selector = this.selector;\n    var subject = this.subjectFactory();\n    var subscription = selector(subject).subscribe(subscriber);\n    subscription.add(source.subscribe(subject));\n    return subscription;\n  };\n  return MulticastOperator;\n}();\nexports.MulticastOperator = MulticastOperator;","map":{"version":3,"mappings":";;AAIA,sCAAuE,qCAAqC,CAAC;AAO7G;AAEA;;;;;;;;;;;;;;;;;;;AAmBA,mBAAgCA,uBAAwD,EACxDC,QAAmD;EACjF,OAAO,mCAAmCC,MAAqB;IAC7D,IAAIC,cAAgC;IACpC,IAAI,OAAOH,uBAAuB,KAAK,UAAU,EAAE;MACjDG,cAAc,GAAqBH,uBAAuB;IAC5D,CAAC,MAAM;MACLG,cAAc,GAAG;QACf,OAAmBH,uBAAuB;MAC5C,CAAC;IACH;IAEA,IAAI,OAAOC,QAAQ,KAAK,UAAU,EAAE;MAClC,OAAOC,MAAM,CAACE,IAAI,CAAC,IAAIC,iBAAiB,CAACF,cAAc,EAAEF,QAAQ,CAAC,CAAC;IACrE;IAEA,IAAMK,WAAW,GAAQC,MAAM,CAACC,MAAM,CAACN,MAAM,EAAEO,uDAA+B,CAAC;IAC/EH,WAAW,CAACJ,MAAM,GAAGA,MAAM;IAC3BI,WAAW,CAACH,cAAc,GAAGA,cAAc;IAE3C,OAAkCG,WAAW;EAC/C,CAAC;AACH;AAtBgBI,iBAAS,YAsBxB;AAED;EACE,2BAAoBP,cAAgC,EAChCF,QAAkD;IADlD,mBAAc,GAAdE,cAAc;IACd,aAAQ,GAARF,QAAQ;EAC5B;EACAI,gCAAI,GAAJ,UAAKM,UAAyB,EAAET,MAAW;IACjC,4BAAQ;IAChB,IAAMU,OAAO,GAAG,IAAI,CAACT,cAAc,EAAE;IACrC,IAAMU,YAAY,GAAGZ,QAAQ,CAACW,OAAO,CAAC,CAACE,SAAS,CAACH,UAAU,CAAC;IAC5DE,YAAY,CAACE,GAAG,CAACb,MAAM,CAACY,SAAS,CAACF,OAAO,CAAC,CAAC;IAC3C,OAAOC,YAAY;EACrB,CAAC;EACH,wBAAC;AAAD,CAAC,EAXD;AAAaH,yBAAiB,oBAW7B","names":["subjectOrSubjectFactory","selector","source","subjectFactory","lift","MulticastOperator","connectable","Object","create","ConnectableObservable_1","exports","subscriber","subject","subscription","subscribe","add"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\src\\operators\\multicast.ts"],"sourcesContent":["import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable, connectableObservableDescriptor } from '../observable/ConnectableObservable';\nimport { FactoryOrValue, MonoTypeOperatorFunction, OperatorFunction, UnaryFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function multicast<T>(subjectOrSubjectFactory: FactoryOrValue<Subject<T>>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector?: MonoTypeOperatorFunction<T>): MonoTypeOperatorFunction<T>;\nexport function multicast<T, R>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector?: OperatorFunction<T, R>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nexport function multicast<T, R>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\n                                selector?: (source: Observable<T>) => Observable<R>): OperatorFunction<T, R> {\n  return function multicastOperatorFunction(source: Observable<T>): Observable<R> {\n    let subjectFactory: () => Subject<T>;\n    if (typeof subjectOrSubjectFactory === 'function') {\n      subjectFactory = <() => Subject<T>>subjectOrSubjectFactory;\n    } else {\n      subjectFactory = function subjectFactory() {\n        return <Subject<T>>subjectOrSubjectFactory;\n      };\n    }\n\n    if (typeof selector === 'function') {\n      return source.lift(new MulticastOperator(subjectFactory, selector));\n    }\n\n    const connectable: any = Object.create(source, connectableObservableDescriptor);\n    connectable.source = source;\n    connectable.subjectFactory = subjectFactory;\n\n    return <ConnectableObservable<R>> connectable;\n  };\n}\n\nexport class MulticastOperator<T, R> implements Operator<T, R> {\n  constructor(private subjectFactory: () => Subject<T>,\n              private selector: (source: Observable<T>) => Observable<R>) {\n  }\n  call(subscriber: Subscriber<R>, source: any): any {\n    const { selector } = this;\n    const subject = this.subjectFactory();\n    const subscription = selector(subject).subscribe(subscriber);\n    subscription.add(source.subscribe(subject));\n    return subscription;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}