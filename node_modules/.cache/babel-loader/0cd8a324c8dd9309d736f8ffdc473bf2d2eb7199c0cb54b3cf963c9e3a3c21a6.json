{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nvar AbstractTextFormatter = /** @class */function () {\n  function AbstractTextFormatter(regularExpression) {\n    this._regularExpression = regularExpression;\n  }\n  AbstractTextFormatter.prototype.format = function (lang, input) {\n    var matches;\n    var result = input;\n    while ((matches = this._regularExpression.exec(input)) != null) {\n      result = result.replace(matches[0], this.internalFormat(lang, matches));\n    }\n    ;\n    return result;\n  };\n  return AbstractTextFormatter;\n}();\nvar DateFormatter = /** @class */function (_super) {\n  __extends(DateFormatter, _super);\n  function DateFormatter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DateFormatter.prototype.internalFormat = function (lang, matches) {\n    var date = new Date(Date.parse(matches[1]));\n    var format = matches[2] != undefined ? matches[2].toLowerCase() : \"compact\";\n    if (format != \"compact\") {\n      return date.toLocaleDateString(lang, {\n        day: \"numeric\",\n        weekday: format,\n        month: format,\n        year: \"numeric\"\n      });\n    } else {\n      return date.toLocaleDateString();\n    }\n  };\n  return DateFormatter;\n}(AbstractTextFormatter);\nvar TimeFormatter = /** @class */function (_super) {\n  __extends(TimeFormatter, _super);\n  function TimeFormatter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TimeFormatter.prototype.internalFormat = function (lang, matches) {\n    var date = new Date(Date.parse(matches[1]));\n    return date.toLocaleTimeString(lang, {\n      hour: 'numeric',\n      minute: '2-digit'\n    });\n  };\n  return TimeFormatter;\n}(AbstractTextFormatter);\nfunction formatText(lang, text) {\n  var formatters = [new DateFormatter(/\\{{2}DATE\\((\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:Z|(?:(?:-|\\+)\\d{2}:\\d{2})))(?:, ?(COMPACT|LONG|SHORT))?\\)\\}{2}/g), new TimeFormatter(/\\{{2}TIME\\((\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:Z|(?:(?:-|\\+)\\d{2}:\\d{2})))\\)\\}{2}/g)];\n  var result = text;\n  for (var i = 0; i < formatters.length; i++) {\n    result = formatters[i].format(lang, result);\n  }\n  return result;\n}\nexports.formatText = formatText;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;EAKI,+BAAYA,iBAAyB;IACjC,IAAI,CAACC,kBAAkB,GAAGD,iBAAiB;EAC/C;EAEAE,sCAAM,GAAN,UAAOC,IAAY,EAAEC,KAAa;IAC9B,IAAIC,OAAO;IACX,IAAIC,MAAM,GAAGF,KAAK;IAElB,OAAO,CAACC,OAAO,GAAG,IAAI,CAACJ,kBAAkB,CAACM,IAAI,CAACH,KAAK,CAAC,KAAK,IAAI,EAAE;MAC5DE,MAAM,GAAGA,MAAM,CAACE,OAAO,CAACH,OAAO,CAAC,CAAC,CAAC,EAAE,IAAI,CAACI,cAAc,CAACN,IAAI,EAAEE,OAAO,CAAC,CAAC;;IAC1E;IAED,OAAOC,MAAM;EACjB,CAAC;EACL,4BAAC;AAAD,CAAC,EAnBD;AAqBA;EAA4BI;EAA5B;;EAYA;EAXcC,sCAAc,GAAxB,UAAyBR,IAAY,EAAEE,OAAwB;IAC3D,IAAIO,IAAI,GAAG,IAAIC,IAAI,CAACA,IAAI,CAACC,KAAK,CAACT,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3C,IAAIU,MAAM,GAAGV,OAAO,CAAC,CAAC,CAAC,IAAIW,SAAS,GAAGX,OAAO,CAAC,CAAC,CAAC,CAACY,WAAW,EAAE,GAAG,SAAS;IAE3E,IAAIF,MAAM,IAAI,SAAS,EAAE;MACrB,OAAOH,IAAI,CAACM,kBAAkB,CAACf,IAAI,EAAE;QAAEgB,GAAG,EAAE,SAAS;QAAEC,OAAO,EAAEL,MAAM;QAAEM,KAAK,EAAEN,MAAM;QAAEO,IAAI,EAAE;MAAS,CAAE,CAAC;KAC5G,MACI;MACD,OAAOV,IAAI,CAACM,kBAAkB,EAAE;;EAExC,CAAC;EACL,oBAAC;AAAD,CAAC,CAZ2BhB,qBAAqB;AAcjD;EAA4BQ;EAA5B;;EAMA;EALca,sCAAc,GAAxB,UAAyBpB,IAAY,EAAEE,OAAwB;IAC3D,IAAIO,IAAI,GAAG,IAAIC,IAAI,CAACA,IAAI,CAACC,KAAK,CAACT,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;IAE3C,OAAOO,IAAI,CAACY,kBAAkB,CAACrB,IAAI,EAAE;MAAEsB,IAAI,EAAE,SAAS;MAAEC,MAAM,EAAE;IAAS,CAAE,CAAC;EAChF,CAAC;EACL,oBAAC;AAAD,CAAC,CAN2BxB,qBAAqB;AAQjD,SAAgByB,UAAU,CAACxB,IAAY,EAAEyB,IAAY;EACjD,IAAMC,UAAU,GAAiC,CAC7C,IAAIlB,aAAa,CAAC,mHAAmH,CAAC,EACtI,IAAIY,aAAa,CAAC,uFAAuF,CAAC,CAC7G;EAED,IAAIjB,MAAM,GAAGsB,IAAI;EAEjB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,UAAU,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IACxCxB,MAAM,GAAGuB,UAAU,CAACC,CAAC,CAAC,CAACf,MAAM,CAACZ,IAAI,EAAEG,MAAM,CAAC;;EAG/C,OAAOA,MAAM;AACjB;AAbA0B","names":["regularExpression","_regularExpression","AbstractTextFormatter","lang","input","matches","result","exec","replace","internalFormat","__extends","DateFormatter","date","Date","parse","format","undefined","toLowerCase","toLocaleDateString","day","weekday","month","year","TimeFormatter","toLocaleTimeString","hour","minute","formatText","text","formatters","i","length","exports"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\adaptivecards\\src\\text-formatters.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nabstract class AbstractTextFormatter {\r\n    private _regularExpression: RegExp;\r\n\r\n    protected abstract internalFormat(lang: string, matches: RegExpExecArray): string;\r\n\r\n    constructor(regularExpression: RegExp) {\r\n        this._regularExpression = regularExpression;\r\n    }\r\n\r\n    format(lang: string, input: string): string {\r\n        var matches;\r\n        var result = input;\r\n\r\n        while ((matches = this._regularExpression.exec(input)) != null) {\r\n            result = result.replace(matches[0], this.internalFormat(lang, matches));\r\n        };\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nclass DateFormatter extends AbstractTextFormatter {\r\n    protected internalFormat(lang: string, matches: RegExpExecArray): string {\r\n        var date = new Date(Date.parse(matches[1]));\r\n        var format = matches[2] != undefined ? matches[2].toLowerCase() : \"compact\";\r\n\r\n        if (format != \"compact\") {\r\n            return date.toLocaleDateString(lang, { day: \"numeric\", weekday: format, month: format, year: \"numeric\" });\r\n        }\r\n        else {\r\n            return date.toLocaleDateString();\r\n        }\r\n    }\r\n}\r\n\r\nclass TimeFormatter extends AbstractTextFormatter {\r\n    protected internalFormat(lang: string, matches: RegExpExecArray): string {\r\n        var date = new Date(Date.parse(matches[1]));\r\n\r\n        return date.toLocaleTimeString(lang, { hour: 'numeric', minute: '2-digit' });\r\n    }\r\n}\r\n\r\nexport function formatText(lang: string, text: string): string {\r\n    const formatters: Array<AbstractTextFormatter> = [\r\n        new DateFormatter(/\\{{2}DATE\\((\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:Z|(?:(?:-|\\+)\\d{2}:\\d{2})))(?:, ?(COMPACT|LONG|SHORT))?\\)\\}{2}/g),\r\n        new TimeFormatter(/\\{{2}TIME\\((\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:Z|(?:(?:-|\\+)\\d{2}:\\d{2})))\\)\\}{2}/g)\r\n    ];\r\n\r\n    var result = text;\r\n\r\n    for (var i = 0; i < formatters.length; i++) {\r\n        result = formatters[i].format(lang, result);\r\n    }\r\n\r\n    return result;\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}