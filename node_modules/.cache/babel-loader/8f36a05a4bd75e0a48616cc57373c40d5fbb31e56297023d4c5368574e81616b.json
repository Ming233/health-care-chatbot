{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar Observable_1 = require('../Observable');\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\nvar refCount_1 = require('../operators/refCount');\n/**\n * @class ConnectableObservable<T>\n */\nvar ConnectableObservable = function (_super) {\n  __extends(ConnectableObservable, _super);\n  function ConnectableObservable( /** @deprecated internal use only */source, /** @deprecated internal use only */subjectFactory) {\n    _super.call(this);\n    this.source = source;\n    this.subjectFactory = subjectFactory;\n    /** @deprecated internal use only */\n    this._refCount = 0;\n    this._isComplete = false;\n  }\n  /** @deprecated internal use only */\n  ConnectableObservable.prototype._subscribe = function (subscriber) {\n    return this.getSubject().subscribe(subscriber);\n  };\n  /** @deprecated internal use only */\n  ConnectableObservable.prototype.getSubject = function () {\n    var subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  };\n  ConnectableObservable.prototype.connect = function () {\n    var connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription_1.Subscription();\n      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription_1.Subscription.EMPTY;\n      } else {\n        this._connection = connection;\n      }\n    }\n    return connection;\n  };\n  ConnectableObservable.prototype.refCount = function () {\n    return refCount_1.refCount()(this);\n  };\n  return ConnectableObservable;\n}(Observable_1.Observable);\nexports.ConnectableObservable = ConnectableObservable;\nvar connectableProto = ConnectableObservable.prototype;\nexports.connectableObservableDescriptor = {\n  operator: {\n    value: null\n  },\n  _refCount: {\n    value: 0,\n    writable: true\n  },\n  _subject: {\n    value: null,\n    writable: true\n  },\n  _connection: {\n    value: null,\n    writable: true\n  },\n  _subscribe: {\n    value: connectableProto._subscribe\n  },\n  _isComplete: {\n    value: connectableProto._isComplete,\n    writable: true\n  },\n  getSubject: {\n    value: connectableProto.getSubject\n  },\n  connect: {\n    value: connectableProto.connect\n  },\n  refCount: {\n    value: connectableProto.refCount\n  }\n};\nvar ConnectableSubscriber = function (_super) {\n  __extends(ConnectableSubscriber, _super);\n  function ConnectableSubscriber(destination, connectable) {\n    _super.call(this, destination);\n    this.connectable = connectable;\n  }\n  ConnectableSubscriber.prototype._error = function (err) {\n    this._unsubscribe();\n    _super.prototype._error.call(this, err);\n  };\n  ConnectableSubscriber.prototype._complete = function () {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    _super.prototype._complete.call(this);\n  };\n  /** @deprecated internal use only */\n  ConnectableSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      var connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  };\n  return ConnectableSubscriber;\n}(Subject_1.SubjectSubscriber);\nvar RefCountOperator = function () {\n  function RefCountOperator(connectable) {\n    this.connectable = connectable;\n  }\n  RefCountOperator.prototype.call = function (subscriber, source) {\n    var connectable = this.connectable;\n    connectable._refCount++;\n    var refCounter = new RefCountSubscriber(subscriber, connectable);\n    var subscription = source.subscribe(refCounter);\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n    return subscription;\n  };\n  return RefCountOperator;\n}();\nvar RefCountSubscriber = function (_super) {\n  __extends(RefCountSubscriber, _super);\n  function RefCountSubscriber(destination, connectable) {\n    _super.call(this, destination);\n    this.connectable = connectable;\n  }\n  /** @deprecated internal use only */\n  RefCountSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n    this.connectable = null;\n    var refCount = connectable._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n    connectable._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // Observable.range(0, 10)\n    //   .publish()\n    //   .refCount()\n    //   .take(5)\n    //   .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    var connection = this.connection;\n    var sharedConnection = connectable._connection;\n    this.connection = null;\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  };\n  return RefCountSubscriber;\n}(Subscriber_1.Subscriber);","map":{"version":3,"mappings":"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","names":["__extends","source","subjectFactory","_super","ConnectableObservable","subscriber","getSubject","subscribe","subject","_subject","isStopped","connection","_connection","_isComplete","Subscription_1","add","ConnectableSubscriber","closed","EMPTY","refCount_1","Observable_1","exports","connectableProto","prototype","operator","value","_refCount","writable","_subscribe","connect","refCount","destination","connectable","err","_unsubscribe","_error","_complete","unsubscribe","Subject_1","RefCountOperator","refCounter","RefCountSubscriber","subscription","sharedConnection","Subscriber_1"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\src\\observable\\ConnectableObservable.ts"],"sourcesContent":["import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  /** @deprecated internal use only */ public _subject: Subject<T>;\n  /** @deprecated internal use only */ public _refCount: number = 0;\n  /** @deprecated internal use only */ public _connection: Subscription;\n  _isComplete = false;\n\n  constructor(/** @deprecated internal use only */ public source: Observable<T>,\n              /** @deprecated internal use only */ public subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  /** @deprecated internal use only */ public getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      } else {\n        this._connection = connection;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nconst connectableProto = <any>ConnectableObservable.prototype;\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = {\n  operator: { value: null },\n  _refCount: { value: 0, writable: true },\n  _subject: { value: null, writable: true },\n  _connection: { value: null, writable: true },\n  _subscribe: { value: connectableProto._subscribe },\n  _isComplete: { value: connectableProto._isComplete, writable: true },\n  getSubject: { value: connectableProto.getSubject },\n  connect: { value: connectableProto.connect },\n  refCount: { value: connectableProto.refCount }\n};\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  /** @deprecated internal use only */ _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // Observable.range(0, 10)\n    //   .publish()\n    //   .refCount()\n    //   .take(5)\n    //   .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}