{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BrowserWebSocket = /** @class */function () {\n  /**\n   * Creates a new instance of the [BrowserWebSocket](xref:botframework-streaming.BrowserWebSocket) class.\n   *\n   * @param socket The socket object to build this connection on.\n   */\n  function BrowserWebSocket(socket) {\n    if (socket) {\n      this.webSocket = socket;\n    }\n  }\n  /**\n   * Connects to the supporting socket using WebSocket protocol.\n   *\n   * @param serverAddress The address the server is listening on.\n   */\n  BrowserWebSocket.prototype.connect = function (serverAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var resolver, rejector;\n      return __generator(this, function (_a) {\n        if (!this.webSocket) {\n          this.webSocket = new WebSocket(serverAddress);\n        }\n        this.webSocket.onerror = function (e) {\n          rejector(e);\n        };\n        this.webSocket.onopen = function (e) {\n          resolver(e);\n        };\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          resolver = resolve;\n          rejector = reject;\n        })];\n      });\n    });\n  };\n  Object.defineProperty(BrowserWebSocket.prototype, \"isConnected\", {\n    /**\n     * True if the socket is currently connected.\n     */\n    get: function () {\n      return this.webSocket.readyState === 1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Writes a buffer to the socket and sends it.\n   *\n   * @param buffer The buffer of data to send across the connection.\n   */\n  BrowserWebSocket.prototype.write = function (buffer) {\n    this.webSocket.send(buffer);\n  };\n  /**\n   * Close the socket.\n   */\n  BrowserWebSocket.prototype.close = function () {\n    this.webSocket.close();\n  };\n  /**\n   * Set the handler for text and binary messages received on the socket.\n   */\n  BrowserWebSocket.prototype.setOnMessageHandler = function (handler) {\n    var bufferKey = 'buffer';\n    var packets = [];\n    this.webSocket.onmessage = function (evt) {\n      var fileReader = new FileReader();\n      var queueEntry = {\n        buffer: null\n      };\n      packets.push(queueEntry);\n      fileReader.onload = function (e) {\n        var t = e.target;\n        queueEntry[bufferKey] = t.result;\n        if (packets[0] === queueEntry) {\n          while (0 < packets.length && packets[0][bufferKey]) {\n            handler(packets[0][bufferKey]);\n            packets.splice(0, 1);\n          }\n        }\n      };\n      fileReader.readAsArrayBuffer(evt.data);\n    };\n  };\n  /**\n   * Set the callback to call when encountering errors.\n   */\n  BrowserWebSocket.prototype.setOnErrorHandler = function (handler) {\n    this.webSocket.onerror = function (error) {\n      if (error) {\n        handler(error);\n      }\n    };\n  };\n  /**\n   * Set the callback to call when encountering socket closures.\n   */\n  BrowserWebSocket.prototype.setOnCloseHandler = function (handler) {\n    this.webSocket.onclose = handler;\n  };\n  return BrowserWebSocket;\n}();\nexports.BrowserWebSocket = BrowserWebSocket;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;EAGI;;;;;EAKA,0BAAmBA,MAA0B;IACzC,IAAIA,MAAM,EAAE;MACR,IAAI,CAACC,SAAS,GAAGD,MAAM;;EAE/B;EAEA;;;;;EAKaE,kCAAO,GAApB,UAAqBC,aAAqB;;;;QAItC,IAAI,CAAC,IAAI,CAACF,SAAS,EAAE;UACjB,IAAI,CAACA,SAAS,GAAG,IAAIG,SAAS,CAACD,aAAa,CAAC;;QAGjD,IAAI,CAACF,SAAS,CAACI,OAAO,GAAG,UAACC,CAAC;UACvBC,QAAQ,CAACD,CAAC,CAAC;QACf,CAAC;QAED,IAAI,CAACL,SAAS,CAACO,MAAM,GAAG,UAACF,CAAC;UACtBG,QAAQ,CAACH,CAAC,CAAC;QACf,CAAC;QAED,sBAAO,IAAII,OAAO,CAAO,UAACC,OAAO,EAAEC,MAAM;UACrCH,QAAQ,GAAGE,OAAO;UAClBJ,QAAQ,GAAGK,MAAM;QACrB,CAAC,CAAC;;;GAEL;EAKDC,sBAAWX,yCAAW;IAHtB;;;SAGA;MACI,OAAO,IAAI,CAACD,SAAS,CAACa,UAAU,KAAK,CAAC;IAC1C,CAAC;;;;EAED;;;;;EAKOZ,gCAAK,GAAZ,UAAaa,MAAmB;IAC5B,IAAI,CAACd,SAAS,CAACe,IAAI,CAACD,MAAM,CAAC;EAC/B,CAAC;EAED;;;EAGOb,gCAAK,GAAZ;IACI,IAAI,CAACD,SAAS,CAACgB,KAAK,EAAE;EAC1B,CAAC;EAED;;;EAGOf,8CAAmB,GAA1B,UAA2BgB,OAAyB;IAChD,IAAMC,SAAS,GAAW,QAAQ;IAClC,IAAMC,OAAO,GAAG,EAAE;IAClB,IAAI,CAACnB,SAAS,CAACoB,SAAS,GAAG,UAACC,GAAG;MAC3B,IAAMC,UAAU,GAAG,IAAIC,UAAU,EAAE;MACnC,IAAMC,UAAU,GAAG;QAAEV,MAAM,EAAE;MAAI,CAAE;MACnCK,OAAO,CAACM,IAAI,CAACD,UAAU,CAAC;MACxBF,UAAU,CAACI,MAAM,GAAG,UAACrB,CAAC;QAClB,IAAMsB,CAAC,GAAGtB,CAAC,CAACuB,MAAuC;QACnDJ,UAAU,CAACN,SAAS,CAAC,GAAGS,CAAC,CAACE,MAAM;QAChC,IAAIV,OAAO,CAAC,CAAC,CAAC,KAAKK,UAAU,EAAE;UAC3B,OAAM,CAAC,GAAGL,OAAO,CAACW,MAAM,IAAIX,OAAO,CAAC,CAAC,CAAC,CAACD,SAAS,CAAC,EAAE;YAC/CD,OAAO,CAACE,OAAO,CAAC,CAAC,CAAC,CAACD,SAAS,CAAC,CAAC;YAC9BC,OAAO,CAACY,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;;;MAGhC,CAAC;MACDT,UAAU,CAACU,iBAAiB,CAACX,GAAG,CAACY,IAAI,CAAC;IAC1C,CAAC;EACL,CAAC;EAED;;;EAGOhC,4CAAiB,GAAxB,UAAyBgB,OAAyB;IAC9C,IAAI,CAACjB,SAAS,CAACI,OAAO,GAAG,UAAC8B,KAAK;MAAa,IAAIA,KAAK,EAAE;QAAEjB,OAAO,CAACiB,KAAK,CAAC;;IAAI,CAAC;EAChF,CAAC;EAED;;;EAGOjC,4CAAiB,GAAxB,UAAyBgB,OAAyB;IAC9C,IAAI,CAACjB,SAAS,CAACmC,OAAO,GAAGlB,OAAO;EACpC,CAAC;EACL,uBAAC;AAAD,CAAC,EAtGD;AAAamB","names":["socket","webSocket","BrowserWebSocket","serverAddress","WebSocket","onerror","e","rejector","onopen","resolver","Promise","resolve","reject","Object","readyState","buffer","send","close","handler","bufferKey","packets","onmessage","evt","fileReader","FileReader","queueEntry","push","onload","t","target","result","length","splice","readAsArrayBuffer","data","error","onclose","exports"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\botframework-streaming\\src\\webSocket\\browserWebSocket.ts"],"sourcesContent":["/**\r\n * @module botframework-streaming\r\n */\r\n/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { IBrowserFileReader, IBrowserWebSocket, ISocket, INodeBuffer } from '../interfaces';\r\n\r\nexport class BrowserWebSocket implements ISocket {\r\n    private webSocket: IBrowserWebSocket;\r\n\r\n    /**\r\n     * Creates a new instance of the [BrowserWebSocket](xref:botframework-streaming.BrowserWebSocket) class.\r\n     *\r\n     * @param socket The socket object to build this connection on.\r\n     */\r\n    public constructor(socket?: IBrowserWebSocket) {\r\n        if (socket) {\r\n            this.webSocket = socket;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connects to the supporting socket using WebSocket protocol.\r\n     *\r\n     * @param serverAddress The address the server is listening on.\r\n     */\r\n    public async connect(serverAddress: string): Promise<void> {\r\n        let resolver;\r\n        let rejector;\r\n\r\n        if (!this.webSocket) {\r\n            this.webSocket = new WebSocket(serverAddress);\r\n        }\r\n\r\n        this.webSocket.onerror = (e): void => {\r\n            rejector(e);\r\n        };\r\n\r\n        this.webSocket.onopen = (e): void => {\r\n            resolver(e);\r\n        };\r\n\r\n        return new Promise<void>((resolve, reject): void => {\r\n            resolver = resolve;\r\n            rejector = reject;\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * True if the socket is currently connected.\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.webSocket.readyState === 1;\r\n    }\r\n\r\n    /**\r\n     * Writes a buffer to the socket and sends it.\r\n     *\r\n     * @param buffer The buffer of data to send across the connection.\r\n     */\r\n    public write(buffer: INodeBuffer): void {\r\n        this.webSocket.send(buffer);\r\n    }\r\n\r\n    /**\r\n     * Close the socket.\r\n     */\r\n    public close(): void {\r\n        this.webSocket.close();\r\n    }\r\n\r\n    /**\r\n     * Set the handler for text and binary messages received on the socket.\r\n     */\r\n    public setOnMessageHandler(handler: (x: any) => void): void {\r\n        const bufferKey: string = 'buffer';\r\n        const packets = [];\r\n        this.webSocket.onmessage = (evt): void => {\r\n            const fileReader = new FileReader();\r\n            const queueEntry = { buffer: null };\r\n            packets.push(queueEntry);\r\n            fileReader.onload = (e): void => {\r\n                const t = e.target as unknown as IBrowserFileReader;\r\n                queueEntry[bufferKey] = t.result;\r\n                if (packets[0] === queueEntry) {\r\n                    while(0 < packets.length && packets[0][bufferKey]) {\r\n                        handler(packets[0][bufferKey]);\r\n                        packets.splice(0, 1);\r\n                    }\r\n                }\r\n            };\r\n            fileReader.readAsArrayBuffer(evt.data);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Set the callback to call when encountering errors.\r\n     */\r\n    public setOnErrorHandler(handler: (x: any) => void): void {\r\n        this.webSocket.onerror = (error): void => { if (error) { handler(error); } };\r\n    }\r\n    \r\n    /**\r\n     * Set the callback to call when encountering socket closures.\r\n     */\r\n    public setOnCloseHandler(handler: (x: any) => void): void {\r\n        this.webSocket.onclose = handler;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}