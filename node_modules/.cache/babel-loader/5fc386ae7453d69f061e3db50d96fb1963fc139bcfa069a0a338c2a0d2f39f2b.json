{"ast":null,"code":"\"use strict\";\n\nvar isArray_1 = require('./util/isArray');\nvar isObject_1 = require('./util/isObject');\nvar isFunction_1 = require('./util/isFunction');\nvar tryCatch_1 = require('./util/tryCatch');\nvar errorObject_1 = require('./util/errorObject');\nvar UnsubscriptionError_1 = require('./util/UnsubscriptionError');\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = function () {\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  function Subscription(unsubscribe) {\n    /**\n     * A flag to indicate whether this Subscription has already been unsubscribed.\n     * @type {boolean}\n     */\n    this.closed = false;\n    this._parent = null;\n    this._parents = null;\n    this._subscriptions = null;\n    if (unsubscribe) {\n      this._unsubscribe = unsubscribe;\n    }\n  }\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  Subscription.prototype.unsubscribe = function () {\n    var hasErrors = false;\n    var errors;\n    if (this.closed) {\n      return;\n    }\n    var _a = this,\n      _parent = _a._parent,\n      _parents = _a._parents,\n      _unsubscribe = _a._unsubscribe,\n      _subscriptions = _a._subscriptions;\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n    var index = -1;\n    var len = _parents ? _parents.length : 0;\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n    if (isFunction_1.isFunction(_unsubscribe)) {\n      var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject_1.errorObject) {\n        hasErrors = true;\n        errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);\n      }\n    }\n    if (isArray_1.isArray(_subscriptions)) {\n      index = -1;\n      len = _subscriptions.length;\n      while (++index < len) {\n        var sub = _subscriptions[index];\n        if (isObject_1.isObject(sub)) {\n          var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject_1.errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            var err = errorObject_1.errorObject.e;\n            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n    if (hasErrors) {\n      throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n    }\n  };\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  Subscription.prototype.add = function (teardown) {\n    if (!teardown || teardown === Subscription.EMPTY) {\n      return Subscription.EMPTY;\n    }\n    if (teardown === this) {\n      return this;\n    }\n    var subscription = teardown;\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          var tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n    var subscriptions = this._subscriptions || (this._subscriptions = []);\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n    return subscription;\n  };\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  Subscription.prototype.remove = function (subscription) {\n    var subscriptions = this._subscriptions;\n    if (subscriptions) {\n      var subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  };\n  Subscription.prototype._addParent = function (parent) {\n    var _a = this,\n      _parent = _a._parent,\n      _parents = _a._parents;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  };\n  Subscription.EMPTY = function (empty) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription());\n  return Subscription;\n}();\nexports.Subscription = Subscription;\nfunction flattenUnsubscriptionErrors(errors) {\n  return errors.reduce(function (errs, err) {\n    return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);\n  }, []);\n}","map":{"version":3,"mappings":"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","names":["unsubscribe","_unsubscribe","Subscription","hasErrors","errors","closed","_parent","_parents","_subscriptions","index","len","length","remove","isFunction_1","trial","tryCatch_1","call","errorObject_1","e","UnsubscriptionError_1","flattenUnsubscriptionErrors","isArray_1","sub","isObject_1","err","concat","push","teardown","EMPTY","subscription","_addParent","tmp","Error","subscriptions","subscriptionIndex","indexOf","splice","parent","empty","exports","reduce","errs"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\src\\Subscription.ts"],"sourcesContent":["import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n\nexport interface AnonymousSubscription {\n  unsubscribe(): void;\n}\n\nexport type TeardownLogic = AnonymousSubscription | Function | void;\n\nexport interface ISubscription extends AnonymousSubscription {\n  unsubscribe(): void;\n  readonly closed: boolean;\n}\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements ISubscription {\n  public static EMPTY: Subscription = (function(empty: any){\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  protected _parent: Subscription = null;\n  protected _parents: Subscription[] = null;\n  private _subscriptions: ISubscription[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}