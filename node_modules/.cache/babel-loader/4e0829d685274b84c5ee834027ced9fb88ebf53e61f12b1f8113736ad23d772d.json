{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar PromiseObservable = function (_super) {\n  __extends(PromiseObservable, _super);\n  function PromiseObservable(promise, scheduler) {\n    _super.call(this);\n    this.promise = promise;\n    this.scheduler = scheduler;\n  }\n  /**\n   * Converts a Promise to an Observable.\n   *\n   * <span class=\"informal\">Returns an Observable that just emits the Promise's\n   * resolved value, then completes.</span>\n   *\n   * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n   * Observable. If the Promise resolves with a value, the output Observable\n   * emits that resolved value as a `next`, and then completes. If the Promise\n   * is rejected, then the output Observable emits the corresponding Error.\n   *\n   * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n   * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   *\n   * @param {PromiseLike<T>} promise The promise to be converted.\n   * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n   * the delivery of the resolved value (or the rejection).\n   * @return {Observable<T>} An Observable which wraps the Promise.\n   * @static true\n   * @name fromPromise\n   * @owner Observable\n   */\n  PromiseObservable.create = function (promise, scheduler) {\n    return new PromiseObservable(promise, scheduler);\n  };\n  /** @deprecated internal use only */\n  PromiseObservable.prototype._subscribe = function (subscriber) {\n    var _this = this;\n    var promise = this.promise;\n    var scheduler = this.scheduler;\n    if (scheduler == null) {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          subscriber.next(this.value);\n          subscriber.complete();\n        }\n      } else {\n        promise.then(function (value) {\n          _this.value = value;\n          _this._isScalar = true;\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        }, function (err) {\n          if (!subscriber.closed) {\n            subscriber.error(err);\n          }\n        }).then(null, function (err) {\n          // escape the promise trap, throw unhandled errors\n          root_1.root.setTimeout(function () {\n            throw err;\n          });\n        });\n      }\n    } else {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          return scheduler.schedule(dispatchNext, 0, {\n            value: this.value,\n            subscriber: subscriber\n          });\n        }\n      } else {\n        promise.then(function (value) {\n          _this.value = value;\n          _this._isScalar = true;\n          if (!subscriber.closed) {\n            subscriber.add(scheduler.schedule(dispatchNext, 0, {\n              value: value,\n              subscriber: subscriber\n            }));\n          }\n        }, function (err) {\n          if (!subscriber.closed) {\n            subscriber.add(scheduler.schedule(dispatchError, 0, {\n              err: err,\n              subscriber: subscriber\n            }));\n          }\n        }).then(null, function (err) {\n          // escape the promise trap, throw unhandled errors\n          root_1.root.setTimeout(function () {\n            throw err;\n          });\n        });\n      }\n    }\n  };\n  return PromiseObservable;\n}(Observable_1.Observable);\nexports.PromiseObservable = PromiseObservable;\nfunction dispatchNext(arg) {\n  var value = arg.value,\n    subscriber = arg.subscriber;\n  if (!subscriber.closed) {\n    subscriber.next(value);\n    subscriber.complete();\n  }\n}\nfunction dispatchError(arg) {\n  var err = arg.err,\n    subscriber = arg.subscriber;\n  if (!subscriber.closed) {\n    subscriber.error(err);\n  }\n}","map":{"version":3,"mappings":"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","names":["__extends","promise","scheduler","_super","PromiseObservable","subscriber","_isScalar","closed","next","value","complete","then","_this","err","error","root_1","setTimeout","schedule","dispatchNext","add","dispatchError","Observable_1","exports","arg"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\src\\observable\\PromiseObservable.ts"],"sourcesContent":["import { root } from '../util/root';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class PromiseObservable<T> extends Observable<T> {\n\n  public value: T;\n\n  /**\n   * Converts a Promise to an Observable.\n   *\n   * <span class=\"informal\">Returns an Observable that just emits the Promise's\n   * resolved value, then completes.</span>\n   *\n   * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n   * Observable. If the Promise resolves with a value, the output Observable\n   * emits that resolved value as a `next`, and then completes. If the Promise\n   * is rejected, then the output Observable emits the corresponding Error.\n   *\n   * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n   * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   *\n   * @param {PromiseLike<T>} promise The promise to be converted.\n   * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n   * the delivery of the resolved value (or the rejection).\n   * @return {Observable<T>} An Observable which wraps the Promise.\n   * @static true\n   * @name fromPromise\n   * @owner Observable\n   */\n  static create<T>(promise: PromiseLike<T>, scheduler?: IScheduler): Observable<T> {\n    return new PromiseObservable(promise, scheduler);\n  }\n\n  constructor(private promise: PromiseLike<T>, private scheduler?: IScheduler) {\n    super();\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const promise = this.promise;\n    const scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          subscriber.next(this.value);\n          subscriber.complete();\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.next(value);\n              subscriber.complete();\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.error(err);\n            }\n          }\n        )\n        .then(null, err => {\n          // escape the promise trap, throw unhandled errors\n          root.setTimeout(() => { throw err; });\n        });\n      }\n    } else {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber });\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchNext, 0, { value, subscriber }));\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchError, 0, { err, subscriber }));\n            }\n          })\n          .then(null, (err) => {\n            // escape the promise trap, throw unhandled errors\n            root.setTimeout(() => { throw err; });\n          });\n      }\n    }\n  }\n}\n\ninterface DispatchNextArg<T> {\n  subscriber: Subscriber<T>;\n  value: T;\n}\nfunction dispatchNext<T>(arg: DispatchNextArg<T>) {\n  const { value, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.next(value);\n    subscriber.complete();\n  }\n}\n\ninterface DispatchErrorArg<T> {\n  subscriber: Subscriber<T>;\n  err: any;\n}\nfunction dispatchError<T>(arg: DispatchErrorArg<T>) {\n  const { err, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.error(err);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}