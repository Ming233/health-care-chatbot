{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectLineStreaming = void 0;\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _BehaviorSubject = require(\"rxjs/BehaviorSubject\");\nvar _Observable = require(\"rxjs/Observable\");\nvar BFSE = _interopRequireWildcard(require(\"botframework-streaming\"));\nvar _crossFetch = _interopRequireDefault(require(\"cross-fetch\"));\nvar _directLine = require(\"./directLine\");\n\n// In order to keep file size down, only import the parts of rxjs that we use\nvar DIRECT_LINE_VERSION = 'DirectLine/3.0';\nvar MAX_RETRY_COUNT = 3;\nvar refreshTokenLifetime = 30 * 60 * 1000; //const refreshTokenLifetime = 5000;\n\nvar timeout = 20 * 1000;\nvar refreshTokenInterval = refreshTokenLifetime / 2;\nvar StreamHandler = /*#__PURE__*/\nfunction () {\n  function StreamHandler(s, c$, sq) {\n    (0, _classCallCheck2[\"default\"])(this, StreamHandler);\n    (0, _defineProperty2[\"default\"])(this, \"connectionStatus$\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"subscriber\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"shouldQueue\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"activityQueue\", []);\n    this.subscriber = s;\n    this.connectionStatus$ = c$;\n    this.shouldQueue = sq;\n  }\n  (0, _createClass2[\"default\"])(StreamHandler, [{\n    key: \"setSubscriber\",\n    value: function setSubscriber(s) {\n      this.subscriber = s;\n    }\n  }, {\n    key: \"processRequest\",\n    value: function () {\n      var _processRequest = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee(request, logger) {\n        var streams, stream0, activitySetJson, activitySet, activity, attachments, stream, attachment, dataUri;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                streams = (0, _toConsumableArray2[\"default\"])(request.streams);\n                stream0 = streams.shift();\n                _context.next = 4;\n                return stream0.readAsString();\n              case 4:\n                activitySetJson = _context.sent;\n                activitySet = JSON.parse(activitySetJson);\n                if (!(activitySet.activities.length !== 1)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                // Only one activity is expected in a set in streaming\n                this.subscriber.error(new Error('there should be exactly one activity'));\n                return _context.abrupt(\"return\", BFSE.StreamingResponse.create(500));\n              case 9:\n                activity = activitySet.activities[0];\n                if (!(streams.length > 0)) {\n                  _context.next = 21;\n                  break;\n                }\n                attachments = (0, _toConsumableArray2[\"default\"])(activity.attachments);\n              case 12:\n                if (!(stream = streams.shift())) {\n                  _context.next = 20;\n                  break;\n                }\n                _context.next = 15;\n                return stream.readAsString();\n              case 15:\n                attachment = _context.sent;\n                dataUri = \"data:text/plain;base64,\" + attachment;\n                attachments.push({\n                  contentType: stream.contentType,\n                  contentUrl: dataUri\n                });\n                _context.next = 12;\n                break;\n              case 20:\n                activity.attachments = attachments;\n              case 21:\n                if (this.shouldQueue()) {\n                  this.activityQueue.push(activity);\n                } else {\n                  this.subscriber.next(activity);\n                }\n                return _context.abrupt(\"return\", BFSE.StreamingResponse.create(200));\n              case 23:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function processRequest(_x, _x2) {\n        return _processRequest.apply(this, arguments);\n      }\n      return processRequest;\n    }()\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var _this = this;\n      this.connectionStatus$.subscribe(function (cs) {});\n      this.activityQueue.forEach(function (a) {\n        return _this.subscriber.next(a);\n      });\n      this.activityQueue = [];\n    }\n  }]);\n  return StreamHandler;\n}();\nvar DirectLineStreaming = /*#__PURE__*/\nfunction () {\n  function DirectLineStreaming(options) {\n    var _this2 = this;\n    (0, _classCallCheck2[\"default\"])(this, DirectLineStreaming);\n    (0, _defineProperty2[\"default\"])(this, \"connectionStatus$\", new _BehaviorSubject.BehaviorSubject(_directLine.ConnectionStatus.Uninitialized));\n    (0, _defineProperty2[\"default\"])(this, \"activity$\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"activitySubscriber\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"theStreamHandler\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"domain\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"conversationId\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"token\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"streamConnection\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"queueActivities\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"_botAgent\", '');\n    this.token = options.token;\n    this.refreshToken();\n    this.domain = options.domain;\n    if (options.conversationId) {\n      this.conversationId = options.conversationId;\n    }\n    this._botAgent = this.getBotAgent(options.botAgent);\n    this.queueActivities = true;\n    this.activity$ = _Observable.Observable.create( /*#__PURE__*/\n    function () {\n      var _ref = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee2(subscriber) {\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _this2.activitySubscriber = subscriber;\n                _this2.theStreamHandler = new StreamHandler(subscriber, _this2.connectionStatus$, function () {\n                  return _this2.queueActivities;\n                });\n                _this2.connectWithRetryAsync();\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      return function (_x3) {\n        return _ref.apply(this, arguments);\n      };\n    }()).share();\n  }\n  (0, _createClass2[\"default\"])(DirectLineStreaming, [{\n    key: \"reconnect\",\n    value: function reconnect(_ref2) {\n      var conversationId = _ref2.conversationId,\n        token = _ref2.token;\n      this.conversationId = conversationId;\n      this.token = token;\n      this.connectAsync();\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      this.connectionStatus$.next(_directLine.ConnectionStatus.Ended);\n      this.streamConnection.disconnect();\n    }\n  }, {\n    key: \"commonHeaders\",\n    value: function commonHeaders() {\n      return {\n        \"Authorization\": \"Bearer \".concat(this.token),\n        \"x-ms-bot-agent\": this._botAgent\n      };\n    }\n  }, {\n    key: \"getBotAgent\",\n    value: function getBotAgent() {\n      var customAgent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var clientAgent = 'directlineStreaming';\n      if (customAgent) {\n        clientAgent += \"; \".concat(customAgent);\n      }\n      return \"\".concat(DIRECT_LINE_VERSION, \" (\").concat(clientAgent, \")\");\n    }\n  }, {\n    key: \"refreshToken\",\n    value: function () {\n      var _refreshToken = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee3() {\n        var firstCall,\n          retryCount,\n          numberOfAttempts,\n          res,\n          _ref3,\n          token,\n          _args3 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                firstCall = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : true;\n                retryCount = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;\n                _context3.next = 4;\n                return this.waitUntilOnline();\n              case 4:\n                numberOfAttempts = 0;\n              case 5:\n                if (!(numberOfAttempts < MAX_RETRY_COUNT)) {\n                  _context3.next = 30;\n                  break;\n                }\n                numberOfAttempts++;\n                _context3.next = 9;\n                return new Promise(function (r) {\n                  return setTimeout(r, refreshTokenInterval);\n                });\n              case 9:\n                _context3.prev = 9;\n                _context3.next = 12;\n                return (0, _crossFetch[\"default\"])(\"\".concat(this.domain, \"/tokens/refresh\"), {\n                  method: \"POST\",\n                  headers: this.commonHeaders()\n                });\n              case 12:\n                res = _context3.sent;\n                if (!res.ok) {\n                  _context3.next = 22;\n                  break;\n                }\n                numberOfAttempts = 0;\n                _context3.next = 17;\n                return res.json();\n              case 17:\n                _ref3 = _context3.sent;\n                token = _ref3.token;\n                this.token = token;\n                _context3.next = 23;\n                break;\n              case 22:\n                if (res.status === 403 || res.status === 403) {\n                  console.error(\"Fatal error while refreshing the token: \".concat(res.status, \" \").concat(res.statusText));\n                  this.streamConnection.disconnect();\n                } else {\n                  console.warn(\"Refresh attempt #\".concat(numberOfAttempts, \" failed: \").concat(res.status, \" \").concat(res.statusText));\n                }\n              case 23:\n                _context3.next = 28;\n                break;\n              case 25:\n                _context3.prev = 25;\n                _context3.t0 = _context3[\"catch\"](9);\n                console.warn(\"Refresh attempt #\".concat(numberOfAttempts, \" threw an exception: \").concat(_context3.t0));\n              case 28:\n                _context3.next = 5;\n                break;\n              case 30:\n                console.error(\"Retries exhausted\");\n                this.streamConnection.disconnect();\n              case 32:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[9, 25]]);\n      }));\n      function refreshToken() {\n        return _refreshToken.apply(this, arguments);\n      }\n      return refreshToken;\n    }()\n  }, {\n    key: \"postActivity\",\n    value: function postActivity(activity) {\n      var _this3 = this;\n      if (activity.type === \"message\" && activity.attachments && activity.attachments.length > 0) {\n        return this.postMessageWithAttachments(activity);\n      }\n      var resp$ = _Observable.Observable.create( /*#__PURE__*/\n      function () {\n        var _ref4 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/\n        _regenerator[\"default\"].mark(function _callee4(subscriber) {\n          var request, resp, numberOfStreams, idString, _JSON$parse, id;\n          return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  request = BFSE.StreamingRequest.create('POST', '/v3/directline/conversations/' + _this3.conversationId + '/activities');\n                  request.setBody(JSON.stringify(activity));\n                  _context4.next = 4;\n                  return _this3.streamConnection.send(request);\n                case 4:\n                  resp = _context4.sent;\n                  _context4.prev = 5;\n                  if (!(resp.statusCode !== 200)) {\n                    _context4.next = 8;\n                    break;\n                  }\n                  throw new Error(\"PostActivity returned \" + resp.statusCode);\n                case 8:\n                  numberOfStreams = resp.streams.length;\n                  if (!(numberOfStreams !== 1)) {\n                    _context4.next = 11;\n                    break;\n                  }\n                  throw new Error(\"Expected one stream but got \" + numberOfStreams);\n                case 11:\n                  _context4.next = 13;\n                  return resp.streams[0].readAsString();\n                case 13:\n                  idString = _context4.sent;\n                  _JSON$parse = JSON.parse(idString), id = _JSON$parse.Id;\n                  return _context4.abrupt(\"return\", subscriber.next(id));\n                case 18:\n                  _context4.prev = 18;\n                  _context4.t0 = _context4[\"catch\"](5);\n                  // If there is a network issue then its handled by\n                  // the disconnectionHandler. Everything else can\n                  // be retried\n                  console.warn(_context4.t0);\n                  _this3.streamConnection.disconnect();\n                  return _context4.abrupt(\"return\", subscriber.error(_context4.t0));\n                case 23:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, null, [[5, 18]]);\n        }));\n        return function (_x4) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n      return resp$;\n    }\n  }, {\n    key: \"postMessageWithAttachments\",\n    value: function postMessageWithAttachments(message) {\n      var _this4 = this;\n      var attachments = message.attachments,\n        messageWithoutAttachments = (0, _objectWithoutProperties2[\"default\"])(message, [\"attachments\"]);\n      return _Observable.Observable.create(function (subscriber) {\n        var httpContentList = [];\n        (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/\n        _regenerator[\"default\"].mark(function _callee6() {\n          var arrayBuffers, url, request, activityStream, resp, _ref8, id;\n          return _regenerator[\"default\"].wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  _context6.prev = 0;\n                  _context6.next = 3;\n                  return Promise.all(attachments.map( /*#__PURE__*/\n                  function () {\n                    var _ref6 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/\n                    _regenerator[\"default\"].mark(function _callee5(attachment) {\n                      var media, res;\n                      return _regenerator[\"default\"].wrap(function _callee5$(_context5) {\n                        while (1) {\n                          switch (_context5.prev = _context5.next) {\n                            case 0:\n                              media = attachment;\n                              _context5.next = 3;\n                              return (0, _crossFetch[\"default\"])(media.contentUrl);\n                            case 3:\n                              res = _context5.sent;\n                              if (!res.ok) {\n                                _context5.next = 12;\n                                break;\n                              }\n                              _context5.next = 7;\n                              return res.arrayBuffer();\n                            case 7:\n                              _context5.t0 = _context5.sent;\n                              _context5.t1 = media;\n                              return _context5.abrupt(\"return\", {\n                                arrayBuffer: _context5.t0,\n                                media: _context5.t1\n                              });\n                            case 12:\n                              throw new Error('...');\n                            case 13:\n                            case \"end\":\n                              return _context5.stop();\n                          }\n                        }\n                      }, _callee5);\n                    }));\n                    return function (_x5) {\n                      return _ref6.apply(this, arguments);\n                    };\n                  }()));\n                case 3:\n                  arrayBuffers = _context6.sent;\n                  arrayBuffers.forEach(function (_ref7) {\n                    var arrayBuffer = _ref7.arrayBuffer,\n                      media = _ref7.media;\n                    var buffer = new Buffer(arrayBuffer);\n                    console.log(buffer);\n                    var stream = new BFSE.SubscribableStream();\n                    stream.write(buffer);\n                    var httpContent = new BFSE.HttpContent({\n                      type: media.contentType,\n                      contentLength: buffer.length\n                    }, stream);\n                    httpContentList.push(httpContent);\n                  });\n                  url = \"/v3/directline/conversations/\".concat(_this4.conversationId, \"/users/\").concat(messageWithoutAttachments.from.id, \"/upload\");\n                  request = BFSE.StreamingRequest.create('PUT', url);\n                  activityStream = new BFSE.SubscribableStream();\n                  activityStream.write(JSON.stringify(messageWithoutAttachments), 'utf-8');\n                  request.addStream(new BFSE.HttpContent({\n                    type: \"application/vnd.microsoft.activity\",\n                    contentLength: activityStream.length\n                  }, activityStream));\n                  httpContentList.forEach(function (e) {\n                    return request.addStream(e);\n                  });\n                  _context6.next = 13;\n                  return _this4.streamConnection.send(request);\n                case 13:\n                  resp = _context6.sent;\n                  if (!(resp.streams && resp.streams.length !== 1)) {\n                    _context6.next = 18;\n                    break;\n                  }\n                  subscriber.error(new Error(\"Invalid stream count \".concat(resp.streams.length)));\n                  _context6.next = 23;\n                  break;\n                case 18:\n                  _context6.next = 20;\n                  return resp.streams[0].readAsJson();\n                case 20:\n                  _ref8 = _context6.sent;\n                  id = _ref8.Id;\n                  subscriber.next(id);\n                case 23:\n                  _context6.next = 28;\n                  break;\n                case 25:\n                  _context6.prev = 25;\n                  _context6.t0 = _context6[\"catch\"](0);\n                  subscriber.error(_context6.t0);\n                case 28:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, null, [[0, 25]]);\n        }))();\n      });\n    }\n  }, {\n    key: \"waitUntilOnline\",\n    value: function () {\n      var _waitUntilOnline = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee7() {\n        var _this5 = this;\n        return _regenerator[\"default\"].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                return _context7.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this5.connectionStatus$.subscribe(function (cs) {\n                    if (cs === _directLine.ConnectionStatus.Online) return resolve();\n                  }, function (e) {\n                    return reject(e);\n                  });\n                }));\n              case 1:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n      function waitUntilOnline() {\n        return _waitUntilOnline.apply(this, arguments);\n      }\n      return waitUntilOnline;\n    }()\n  }, {\n    key: \"connectAsync\",\n    value: function () {\n      var _connectAsync = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee9() {\n        var _this6 = this;\n        var re, params, urlSearchParams, wsUrl;\n        return _regenerator[\"default\"].wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                re = new RegExp('^http(s?)');\n                if (re.test(this.domain)) {\n                  _context9.next = 3;\n                  break;\n                }\n                throw \"Domain must begin with http or https\";\n              case 3:\n                params = {\n                  token: this.token\n                };\n                if (this.conversationId) params['conversationId'] = this.conversationId;\n                urlSearchParams = new URLSearchParams(params).toString();\n                wsUrl = \"\".concat(this.domain.replace(re, 'ws$1'), \"/conversations/connect?\").concat(urlSearchParams);\n                return _context9.abrupt(\"return\", new Promise( /*#__PURE__*/\n                function () {\n                  var _ref9 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/\n                  _regenerator[\"default\"].mark(function _callee8(resolve, reject) {\n                    var request, response, responseString, conversation;\n                    return _regenerator[\"default\"].wrap(function _callee8$(_context8) {\n                      while (1) {\n                        switch (_context8.prev = _context8.next) {\n                          case 0:\n                            _context8.prev = 0;\n                            _this6.streamConnection = new BFSE.WebSocketClient({\n                              url: wsUrl,\n                              requestHandler: _this6.theStreamHandler,\n                              disconnectionHandler: function disconnectionHandler(e) {\n                                return resolve(e);\n                              }\n                            });\n                            _this6.queueActivities = true;\n                            _context8.next = 5;\n                            return _this6.streamConnection.connect();\n                          case 5:\n                            request = BFSE.StreamingRequest.create('POST', '/v3/directline/conversations');\n                            _context8.next = 8;\n                            return _this6.streamConnection.send(request);\n                          case 8:\n                            response = _context8.sent;\n                            if (!(response.statusCode !== 200)) {\n                              _context8.next = 11;\n                              break;\n                            }\n                            throw new Error(\"Connection response code \" + response.statusCode);\n                          case 11:\n                            if (!(response.streams.length !== 1)) {\n                              _context8.next = 13;\n                              break;\n                            }\n                            throw new Error(\"Expected 1 stream but got \" + response.streams.length);\n                          case 13:\n                            _context8.next = 15;\n                            return response.streams[0].readAsString();\n                          case 15:\n                            responseString = _context8.sent;\n                            conversation = JSON.parse(responseString);\n                            _this6.conversationId = conversation.conversationId;\n                            _this6.connectionStatus$.next(_directLine.ConnectionStatus.Online); // Wait until DL consumers have had a chance to be notified\n                            // of the connection status change.\n\n                            _context8.next = 21;\n                            return _this6.waitUntilOnline();\n                          case 21:\n                            _this6.theStreamHandler.flush();\n                            _this6.queueActivities = false;\n                            _context8.next = 28;\n                            break;\n                          case 25:\n                            _context8.prev = 25;\n                            _context8.t0 = _context8[\"catch\"](0);\n                            reject(_context8.t0);\n                          case 28:\n                          case \"end\":\n                            return _context8.stop();\n                        }\n                      }\n                    }, _callee8, null, [[0, 25]]);\n                  }));\n                  return function (_x6, _x7) {\n                    return _ref9.apply(this, arguments);\n                  };\n                }()));\n              case 8:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n      function connectAsync() {\n        return _connectAsync.apply(this, arguments);\n      }\n      return connectAsync;\n    }()\n  }, {\n    key: \"connectWithRetryAsync\",\n    value: function () {\n      var _connectWithRetryAsync = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee10() {\n        var _this7 = this;\n        var numRetries, start, res;\n        return _regenerator[\"default\"].wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                numRetries = MAX_RETRY_COUNT;\n              case 1:\n                if (!(numRetries > 0)) {\n                  _context10.next = 23;\n                  break;\n                }\n                numRetries--;\n                start = Date.now();\n                _context10.prev = 4;\n                this.connectionStatus$.next(_directLine.ConnectionStatus.Connecting);\n                _context10.next = 8;\n                return this.connectAsync();\n              case 8:\n                res = _context10.sent;\n                console.warn(\"Retrying connection \".concat(res));\n                if (!(60000 < Date.now() - start)) {\n                  _context10.next = 13;\n                  break;\n                }\n\n                // reset the retry counter and retry immediately\n                // if the connection lasted for more than a minute\n                numRetries = MAX_RETRY_COUNT;\n                return _context10.abrupt(\"continue\", 1);\n              case 13:\n                _context10.next = 19;\n                break;\n              case 15:\n                _context10.prev = 15;\n                _context10.t0 = _context10[\"catch\"](4);\n                console.error(\"Failed to connect \".concat(_context10.t0));\n                throw _context10.t0;\n              case 19:\n                _context10.next = 21;\n                return new Promise(function (r) {\n                  return setTimeout(r, _this7.getRetryDelay());\n                });\n              case 21:\n                _context10.next = 1;\n                break;\n              case 23:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[4, 15]]);\n      }));\n      function connectWithRetryAsync() {\n        return _connectWithRetryAsync.apply(this, arguments);\n      }\n      return connectWithRetryAsync;\n    }() // Returns the delay duration in milliseconds\n  }, {\n    key: \"getRetryDelay\",\n    value: function getRetryDelay() {\n      return Math.floor(3000 + Math.random() * 12000);\n    }\n  }]);\n  return DirectLineStreaming;\n}();\nexports.DirectLineStreaming = DirectLineStreaming;","map":{"version":3,"mappings":"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","names":["DIRECT_LINE_VERSION","MAX_RETRY_COUNT","refreshTokenLifetime","timeout","refreshTokenInterval","StreamHandler","s","c$","sq","subscriber","connectionStatus$","shouldQueue","request","logger","streams","stream0","shift","readAsString","activitySetJson","activitySet","JSON","parse","activities","length","error","Error","BFSE","StreamingResponse","create","activity","attachments","stream","attachment","dataUri","push","contentType","contentUrl","activityQueue","next","subscribe","forEach","a","_this","DirectLineStreaming","options","BehaviorSubject","ConnectionStatus","Uninitialized","token","refreshToken","domain","conversationId","_botAgent","getBotAgent","botAgent","queueActivities","activity$","Observable","_regenerator","_this2","activitySubscriber","theStreamHandler","connectWithRetryAsync","share","connectAsync","Ended","streamConnection","disconnect","customAgent","clientAgent","firstCall","retryCount","waitUntilOnline","numberOfAttempts","Promise","setTimeout","r","method","headers","commonHeaders","res","ok","json","status","console","statusText","warn","type","postMessageWithAttachments","resp$","StreamingRequest","_this3","setBody","stringify","_context4","send","resp","statusCode","numberOfStreams","idString","_JSON$parse","id","Id","message","messageWithoutAttachments","httpContentList","_context6","all","map","media","_context5","arrayBuffer","arrayBuffers","buffer","Buffer","log","SubscribableStream","write","httpContent","HttpContent","contentLength","url","_this4","from","activityStream","addStream","e","readAsJson","_ref8","resolve","reject","_this5","cs","Online","re","RegExp","test","params","urlSearchParams","URLSearchParams","toString","wsUrl","replace","_context8","_this6","WebSocketClient","requestHandler","disconnectionHandler","connect","response","responseString","conversation","flush","numRetries","start","Date","now","Connecting","_this7","getRetryDelay","Math","floor","random"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\botframework-directlinejs\\src\\directLineStreaming.ts"],"sourcesContent":["// In order to keep file size down, only import the parts of rxjs that we use\n\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { Subscriber } from 'rxjs/Subscriber';\nimport * as BFSE from 'botframework-streaming';\nimport fetch from 'cross-fetch';\n\nimport {\n  Activity,\n  ConnectionStatus,\n  Conversation,\n  IBotConnection,\n  Media,\n  Message\n} from './directLine';\n\nconst DIRECT_LINE_VERSION = 'DirectLine/3.0';\nconst MAX_RETRY_COUNT = 3;\nconst refreshTokenLifetime = 30 * 60 * 1000;\n//const refreshTokenLifetime = 5000;\nconst timeout = 20 * 1000;\nconst refreshTokenInterval = refreshTokenLifetime / 2;\n\ninterface DirectLineStreamingOptions {\n  token: string,\n  conversationId?: string,\n  domain: string,\n  // Attached to all requests to identify requesting agent.\n  botAgent?: string\n}\n\nclass StreamHandler implements BFSE.RequestHandler {\n  private connectionStatus$;\n  private subscriber: Subscriber<Activity>;\n  private shouldQueue: () => boolean;\n  private activityQueue: Array<Activity> = [];\n\n  constructor(s: Subscriber<Activity>, c$: Observable<ConnectionStatus>, sq: () => boolean) {\n    this.subscriber = s;\n    this.connectionStatus$ = c$;\n    this.shouldQueue = sq;\n  }\n\n  public setSubscriber(s: Subscriber<Activity>) {\n    this.subscriber = s;\n  }\n\n  async processRequest(request: BFSE.IReceiveRequest, logger?: any): Promise<BFSE.StreamingResponse> {\n    const streams = [...request.streams];\n    const stream0 = streams.shift();\n    const activitySetJson = await stream0.readAsString();\n    const activitySet = JSON.parse(activitySetJson);\n\n    if (activitySet.activities.length !== 1) {\n      // Only one activity is expected in a set in streaming\n      this.subscriber.error(new Error('there should be exactly one activity'));\n      return BFSE.StreamingResponse.create(500);\n    }\n\n    const activity = activitySet.activities[0];\n\n    if (streams.length > 0) {\n      const attachments = [...activity.attachments];\n\n      let stream: BFSE.ContentStream;\n      while (stream = streams.shift()) {\n        const attachment = await stream.readAsString();\n        const dataUri = \"data:text/plain;base64,\" + attachment;\n        attachments.push({ contentType: stream.contentType, contentUrl: dataUri });\n      }\n\n      activity.attachments = attachments;\n    }\n\n    if (this.shouldQueue()) {\n      this.activityQueue.push(activity);\n    } else {\n      this.subscriber.next(activity);\n    }\n\n    return BFSE.StreamingResponse.create(200);\n  }\n\n  public flush() {\n    this.connectionStatus$.subscribe(cs => { })\n    this.activityQueue.forEach((a) => this.subscriber.next(a));\n    this.activityQueue = [];\n  }\n}\n\nexport class DirectLineStreaming implements IBotConnection {\n  public connectionStatus$ = new BehaviorSubject(ConnectionStatus.Uninitialized);\n  public activity$: Observable<Activity>;\n\n  private activitySubscriber: Subscriber<Activity>;\n  private theStreamHandler: StreamHandler;\n\n  private domain: string;\n\n  private conversationId: string;\n  private token: string;\n  private streamConnection: BFSE.WebSocketClient;\n  private queueActivities: boolean;\n\n  private _botAgent = '';\n\n  constructor(options: DirectLineStreamingOptions) {\n    this.token = options.token;\n\n    this.refreshToken();\n\n    this.domain = options.domain;\n\n    if (options.conversationId) {\n      this.conversationId = options.conversationId;\n    }\n\n    this._botAgent = this.getBotAgent(options.botAgent);\n\n    this.queueActivities = true;\n    this.activity$ = Observable.create(async (subscriber: Subscriber<Activity>) => {\n      this.activitySubscriber = subscriber;\n      this.theStreamHandler = new StreamHandler(subscriber, this.connectionStatus$, () => this.queueActivities);\n      this.connectWithRetryAsync();\n    }).share();\n  }\n\n  public reconnect({ conversationId, token } : Conversation) {\n    this.conversationId = conversationId;\n    this.token = token;\n    this.connectAsync();\n  }\n\n  end() {\n    this.connectionStatus$.next(ConnectionStatus.Ended);\n    this.streamConnection.disconnect();\n  }\n\n  private commonHeaders() {\n    return {\n      \"Authorization\": `Bearer ${this.token}`,\n      \"x-ms-bot-agent\": this._botAgent\n    };\n  }\n\n  private getBotAgent(customAgent: string = ''): string {\n    let clientAgent = 'directlineStreaming'\n\n    if (customAgent) {\n      clientAgent += `; ${customAgent}`\n    }\n\n    return `${DIRECT_LINE_VERSION} (${clientAgent})`;\n  }\n\n  private async refreshToken(firstCall = true, retryCount = 0) {\n    await this.waitUntilOnline();\n\n    let numberOfAttempts = 0;\n    while(numberOfAttempts < MAX_RETRY_COUNT) {\n      numberOfAttempts++;\n      await new Promise(r => setTimeout(r, refreshTokenInterval));\n      try {\n        const res = await fetch(`${this.domain}/tokens/refresh`, {method: \"POST\", headers: this.commonHeaders()});\n        if (res.ok) {\n          numberOfAttempts = 0;\n          const {token} = await res.json();\n          this.token = token;\n        } else {\n          if (res.status === 403 || res.status === 403) {\n            console.error(`Fatal error while refreshing the token: ${res.status} ${res.statusText}`);\n            this.streamConnection.disconnect();\n          } else {\n            console.warn(`Refresh attempt #${numberOfAttempts} failed: ${res.status} ${res.statusText}`);\n          }\n        }\n      } catch(e) {\n        console.warn(`Refresh attempt #${numberOfAttempts} threw an exception: ${e}`);\n      }\n    }\n\n    console.error(\"Retries exhausted\");\n    this.streamConnection.disconnect();\n  }\n\n  postActivity(activity: Activity) {\n    if (activity.type === \"message\" && activity.attachments && activity.attachments.length > 0) {\n      return this.postMessageWithAttachments(activity);\n    }\n\n    const resp$ = Observable.create(async subscriber => {\n      const request = BFSE.StreamingRequest.create('POST', '/v3/directline/conversations/' + this.conversationId + '/activities');\n      request.setBody(JSON.stringify(activity));\n      const resp = await this.streamConnection.send(request);\n\n      try {\n        if (resp.statusCode !== 200) throw new Error(\"PostActivity returned \" + resp.statusCode);\n        const numberOfStreams = resp.streams.length;\n        if (numberOfStreams !== 1) throw new Error(\"Expected one stream but got \" + numberOfStreams)\n        const idString = await resp.streams[0].readAsString();\n        const {Id : id} = JSON.parse(idString);\n        return subscriber.next(id);\n      } catch(e) {\n          // If there is a network issue then its handled by\n          // the disconnectionHandler. Everything else can\n          // be retried\n          console.warn(e);\n          this.streamConnection.disconnect();\n          return subscriber.error(e);\n      }\n    });\n    return resp$;\n  }\n\n  private postMessageWithAttachments(message: Message) {\n    const { attachments, ...messageWithoutAttachments } = message;\n\n    return Observable.create( subscriber => {\n      const httpContentList = [];\n      (async () => {\n        try {\n          const arrayBuffers = await Promise.all(attachments.map(async attachment => {\n            const media = attachment as Media;\n            const res = await fetch(media.contentUrl);\n            if (res.ok) {\n              return { arrayBuffer: await res.arrayBuffer(), media };\n            } else {\n              throw new Error('...');\n            }\n          }));\n\n          arrayBuffers.forEach(({ arrayBuffer, media }) => {\n            const buffer = new Buffer(arrayBuffer);\n            console.log(buffer);\n            const stream = new BFSE.SubscribableStream();\n            stream.write(buffer);\n            const httpContent = new BFSE.HttpContent({ type: media.contentType, contentLength: buffer.length }, stream);\n            httpContentList.push(httpContent);\n          });\n\n          const url = `/v3/directline/conversations/${this.conversationId}/users/${messageWithoutAttachments.from.id}/upload`;\n          const request = BFSE.StreamingRequest.create('PUT', url);\n          const activityStream = new BFSE.SubscribableStream();\n          activityStream.write(JSON.stringify(messageWithoutAttachments), 'utf-8');\n          request.addStream(new BFSE.HttpContent({ type: \"application/vnd.microsoft.activity\", contentLength: activityStream.length }, activityStream));\n          httpContentList.forEach(e => request.addStream(e));\n\n          const resp = await this.streamConnection.send(request);\n          if (resp.streams && resp.streams.length !== 1) {\n            subscriber.error(new Error(`Invalid stream count ${resp.streams.length}`));\n          } else {\n            const {Id: id} = await resp.streams[0].readAsJson();\n            subscriber.next(id);\n          }\n        } catch(e) {\n          subscriber.error(e);\n        }\n      })();\n    });\n  }\n\n  private async waitUntilOnline() {\n    return new Promise<void>((resolve, reject) => {\n      this.connectionStatus$.subscribe((cs) => {\n        if (cs === ConnectionStatus.Online) return resolve();\n      },\n        (e) => reject(e));\n    })\n  }\n\n  private async connectAsync() {\n    const re = new RegExp('^http(s?)');\n    if (!re.test(this.domain)) throw (\"Domain must begin with http or https\");\n    const params = {token: this.token};\n    if (this.conversationId) params['conversationId'] = this.conversationId;\n    const urlSearchParams = new URLSearchParams(params).toString();\n    const wsUrl = `${this.domain.replace(re, 'ws$1')}/conversations/connect?${urlSearchParams}`;\n\n    return new Promise(async (resolve, reject) => {\n      try {\n        this.streamConnection = new BFSE.WebSocketClient({\n          url: wsUrl,\n          requestHandler: this.theStreamHandler,\n          disconnectionHandler: (e) => resolve(e)\n        });\n\n        this.queueActivities = true;\n        await this.streamConnection.connect();\n        const request = BFSE.StreamingRequest.create('POST', '/v3/directline/conversations');\n        const response = await this.streamConnection.send(request);\n        if (response.statusCode !== 200) throw new Error(\"Connection response code \" + response.statusCode);\n        if (response.streams.length !== 1) throw new Error(\"Expected 1 stream but got \" + response.streams.length);\n        const responseString = await response.streams[0].readAsString();\n        const conversation = JSON.parse(responseString);\n        this.conversationId = conversation.conversationId;\n        this.connectionStatus$.next(ConnectionStatus.Online);\n\n        // Wait until DL consumers have had a chance to be notified\n        // of the connection status change.\n        await this.waitUntilOnline();\n        this.theStreamHandler.flush();\n        this.queueActivities = false;\n      } catch(e) {\n        reject(e);\n      }\n    });\n  }\n\n  private async connectWithRetryAsync() {\n    let numRetries = MAX_RETRY_COUNT;\n    while (numRetries > 0) {\n      numRetries--;\n      const start = Date.now();\n      try {\n        this.connectionStatus$.next(ConnectionStatus.Connecting);\n        const res = await this.connectAsync();\n        console.warn(`Retrying connection ${res}`);\n        if (60000 < Date.now() - start) {\n          // reset the retry counter and retry immediately\n          // if the connection lasted for more than a minute\n          numRetries = MAX_RETRY_COUNT;\n          continue;\n        }\n      } catch (err) {\n        console.error(`Failed to connect ${err}`);\n        throw(err);\n      }\n\n      await new Promise(r => setTimeout(r, this.getRetryDelay()));\n    }\n  }\n\n  // Returns the delay duration in milliseconds\n  private getRetryDelay() {\n    return Math.floor(3000 + Math.random() * 12000);\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}