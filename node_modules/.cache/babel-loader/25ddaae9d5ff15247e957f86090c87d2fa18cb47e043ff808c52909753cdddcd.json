{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = require('../Scheduler');\nvar AsyncScheduler = function (_super) {\n  __extends(AsyncScheduler, _super);\n  function AsyncScheduler() {\n    _super.apply(this, arguments);\n    this.actions = [];\n    /**\n     * A flag to indicate whether the Scheduler is currently executing a batch of\n     * queued actions.\n     * @type {boolean}\n     */\n    this.active = false;\n    /**\n     * An internal ID used to track the latest asynchronous task such as those\n     * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n     * others.\n     * @type {any}\n     */\n    this.scheduled = undefined;\n  }\n  AsyncScheduler.prototype.flush = function (action) {\n    var actions = this.actions;\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n    var error;\n    this.active = true;\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n    this.active = false;\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  };\n  return AsyncScheduler;\n}(Scheduler_1.Scheduler);\nexports.AsyncScheduler = AsyncScheduler;","map":{"version":3,"mappings":";;;;;;;;;AAAA,0BAA0B,cAAc,CAAC;AAGzC;EAAoCA;EAApC;IAAoCC;IAC3B,YAAO,GAA4B,EAAE;IAC5C;;;;;IAKO,WAAM,GAAY,KAAK;IAC9B;;;;;;IAMO,cAAS,GAAQC,SAAS;EA6BnC;EA3BSC,8BAAK,GAAZ,UAAaC,MAAwB;IAE5B,0BAAO;IAEd,IAAI,IAAI,CAACC,MAAM,EAAE;MACfC,OAAO,CAACC,IAAI,CAACH,MAAM,CAAC;MACpB;IACF;IAEA,IAAII,KAAU;IACd,IAAI,CAACH,MAAM,GAAG,IAAI;IAElB,GAAG;MACD,IAAIG,KAAK,GAAGJ,MAAM,CAACK,OAAO,CAACL,MAAM,CAACM,KAAK,EAAEN,MAAM,CAACO,KAAK,CAAC,EAAE;QACtD;MACF;IACF,CAAC,QAAQP,MAAM,GAAGE,OAAO,CAACM,KAAK,EAAE,EAAE,CAAC;IAEpC,IAAI,CAACP,MAAM,GAAG,KAAK;IAEnB,IAAIG,KAAK,EAAE;MACT,OAAOJ,MAAM,GAAGE,OAAO,CAACM,KAAK,EAAE,EAAE;QAC/BR,MAAM,CAACS,WAAW,EAAE;MACtB;MACA,MAAML,KAAK;IACb;EACF,CAAC;EACH,qBAAC;AAAD,CAAC,CA3CmCM,qBAAS;AAAhCC,sBAAc,iBA2C1B","names":["__extends","_super","undefined","AsyncScheduler","action","active","actions","push","error","execute","state","delay","shift","unsubscribe","Scheduler_1","exports"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\src\\scheduler\\AsyncScheduler.ts"],"sourcesContent":["import { Scheduler } from '../Scheduler';\nimport { AsyncAction } from './AsyncAction';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   */\n  public scheduled: any = undefined;\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}