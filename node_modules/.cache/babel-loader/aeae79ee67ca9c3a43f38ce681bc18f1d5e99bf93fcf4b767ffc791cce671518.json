{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar payloadTypes_1 = require(\"../payloads/payloadTypes\");\nvar headerSerializer_1 = require(\"../payloads/headerSerializer\");\nvar payloadConstants_1 = require(\"../payloads/payloadConstants\");\nvar transportDisconnectedEvent_1 = require(\"./transportDisconnectedEvent\");\n/**\n * Payload receiver for streaming.\n */\nvar PayloadReceiver = /** @class */function () {\n  function PayloadReceiver() {\n    this.disconnected = function (sender, events) {};\n  }\n  /**\n   * Connects to a transport receiver\n   *\n   * @param receiver The [ITransportReceiver](xref:botframework-streaming.ITransportReceiver) object to pull incoming data from.\n   */\n  PayloadReceiver.prototype.connect = function (receiver) {\n    if (this.isConnected) {\n      throw new Error('Already connected.');\n    } else {\n      this._receiver = receiver;\n      this.isConnected = true;\n      this.runReceive();\n    }\n  };\n  /**\n   * Allows subscribing to this receiver in order to be notified when new data comes in.\n   *\n   * @param getStream Callback when a new stream has been received.\n   * @param receiveAction Callback when a new message has been received.\n   */\n  PayloadReceiver.prototype.subscribe = function (getStream, receiveAction) {\n    this._getStream = getStream;\n    this._receiveAction = receiveAction;\n  };\n  /**\n   * Force this receiver to disconnect.\n   *\n   * @param e Event arguments to include when broadcasting disconnection event.\n   */\n  PayloadReceiver.prototype.disconnect = function (e) {\n    var didDisconnect;\n    try {\n      if (this.isConnected) {\n        this._receiver.close();\n        didDisconnect = true;\n        this.isConnected = false;\n      }\n    } catch (error) {\n      this.isConnected = false;\n      this.disconnected(this, new transportDisconnectedEvent_1.TransportDisconnectedEvent(error.message));\n    }\n    this._receiver = null;\n    this.isConnected = false;\n    if (didDisconnect) {\n      this.disconnected(this, e || transportDisconnectedEvent_1.TransportDisconnectedEvent.Empty);\n    }\n  };\n  PayloadReceiver.prototype.runReceive = function () {\n    this.receivePackets().catch();\n  };\n  PayloadReceiver.prototype.receivePackets = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var isClosed, readSoFar, _a, header, isStream, bytesActuallyRead, contentStream, count, _b, error_1;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(this.isConnected && !isClosed)) return [3 /*break*/, 11];\n            _c.label = 1;\n          case 1:\n            _c.trys.push([1, 9,, 10]);\n            readSoFar = 0;\n            _c.label = 2;\n          case 2:\n            if (!(readSoFar < payloadConstants_1.PayloadConstants.MaxHeaderLength)) return [3 /*break*/, 4];\n            _a = this;\n            return [4 /*yield*/, this._receiver.receive(payloadConstants_1.PayloadConstants.MaxHeaderLength - readSoFar)];\n          case 3:\n            _a._receiveHeaderBuffer = _c.sent();\n            if (this._receiveHeaderBuffer) {\n              readSoFar += this._receiveHeaderBuffer.length;\n            }\n            return [3 /*break*/, 2];\n          case 4:\n            header = headerSerializer_1.HeaderSerializer.deserialize(this._receiveHeaderBuffer);\n            isStream = header.payloadType === payloadTypes_1.PayloadTypes.stream;\n            if (!(header.payloadLength > 0)) return [3 /*break*/, 8];\n            bytesActuallyRead = 0;\n            contentStream = this._getStream(header);\n            _c.label = 5;\n          case 5:\n            if (!(bytesActuallyRead < header.payloadLength && bytesActuallyRead < payloadConstants_1.PayloadConstants.MaxPayloadLength)) return [3 /*break*/, 7];\n            count = Math.min(header.payloadLength - bytesActuallyRead, payloadConstants_1.PayloadConstants.MaxPayloadLength);\n            _b = this;\n            return [4 /*yield*/, this._receiver.receive(count)];\n          case 6:\n            _b._receivePayloadBuffer = _c.sent();\n            bytesActuallyRead += this._receivePayloadBuffer.byteLength;\n            contentStream.write(this._receivePayloadBuffer);\n            // If this is a stream we want to keep handing it up as it comes in\n            if (isStream) {\n              this._receiveAction(header, contentStream, bytesActuallyRead);\n            }\n            return [3 /*break*/, 5];\n          case 7:\n            if (!isStream) {\n              this._receiveAction(header, contentStream, bytesActuallyRead);\n            }\n            _c.label = 8;\n          case 8:\n            return [3 /*break*/, 10];\n          case 9:\n            error_1 = _c.sent();\n            isClosed = true;\n            this.disconnect(new transportDisconnectedEvent_1.TransportDisconnectedEvent(error_1.message));\n            return [3 /*break*/, 10];\n          case 10:\n            return [3 /*break*/, 0];\n          case 11:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return PayloadReceiver;\n}();\nexports.PayloadReceiver = PayloadReceiver;","map":{"version":3,"mappings":"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","names":["sender","events","PayloadReceiver","receiver","isConnected","Error","_receiver","runReceive","getStream","receiveAction","_getStream","_receiveAction","e","didDisconnect","close","error","disconnected","transportDisconnectedEvent_1","message","Empty","receivePackets","catch","isClosed","readSoFar","payloadConstants_1","MaxHeaderLength","_a","receive","_receiveHeaderBuffer","_c","length","header","headerSerializer_1","deserialize","isStream","payloadType","payloadTypes_1","stream","payloadLength","bytesActuallyRead","contentStream","MaxPayloadLength","count","Math","min","_b","_receivePayloadBuffer","byteLength","write","disconnect","error_1","exports"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\botframework-streaming\\src\\payloadTransport\\payloadReceiver.ts"],"sourcesContent":["/**\r\n * @module botframework-streaming\r\n */\r\n/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport { TransportDisconnectedEventHandler } from '.';\r\nimport { PayloadTypes } from '../payloads/payloadTypes';\r\nimport { HeaderSerializer } from '../payloads/headerSerializer';\r\nimport { SubscribableStream } from '../subscribableStream';\r\nimport { PayloadConstants } from '../payloads/payloadConstants';\r\nimport { TransportDisconnectedEvent } from './transportDisconnectedEvent';\r\nimport { ITransportReceiver } from '../interfaces/ITransportReceiver';\r\nimport { IHeader } from '../interfaces/IHeader';\r\nimport { INodeBuffer } from '../interfaces/INodeBuffer';\r\n\r\n/**\r\n * Payload receiver for streaming.\r\n */\r\nexport class PayloadReceiver {\r\n    public isConnected: boolean;\r\n    public disconnected: TransportDisconnectedEventHandler = function(sender, events){};\r\n    private _receiver: ITransportReceiver;\r\n    private _receiveHeaderBuffer: INodeBuffer;\r\n    private _receivePayloadBuffer: INodeBuffer;\r\n    private _getStream: (header: IHeader) => SubscribableStream;\r\n    private _receiveAction: (header: IHeader, stream: SubscribableStream, length: number) => void;\r\n\r\n    /**\r\n     * Connects to a transport receiver\r\n     *\r\n     * @param receiver The [ITransportReceiver](xref:botframework-streaming.ITransportReceiver) object to pull incoming data from.\r\n     */\r\n    public connect(receiver: ITransportReceiver): void {\r\n        if (this.isConnected) {\r\n            throw new Error('Already connected.');\r\n        } else {\r\n            this._receiver = receiver;\r\n            this.isConnected = true;\r\n            this.runReceive();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows subscribing to this receiver in order to be notified when new data comes in.\r\n     *\r\n     * @param getStream Callback when a new stream has been received.\r\n     * @param receiveAction Callback when a new message has been received.\r\n     */\r\n    public subscribe(getStream: (header: IHeader) => SubscribableStream, receiveAction: (header: IHeader, stream: SubscribableStream, count: number) => void): void {\r\n        this._getStream = getStream;\r\n        this._receiveAction = receiveAction;\r\n    }\r\n\r\n    /**\r\n     * Force this receiver to disconnect.\r\n     *\r\n     * @param e Event arguments to include when broadcasting disconnection event.\r\n     */\r\n    public disconnect(e?: TransportDisconnectedEvent): void {\r\n        let didDisconnect;\r\n        try {\r\n            if (this.isConnected) {\r\n                this._receiver.close();\r\n                didDisconnect = true;\r\n                this.isConnected = false;\r\n            }\r\n        } catch (error) {\r\n            this.isConnected = false;\r\n            this.disconnected(this, new TransportDisconnectedEvent(error.message));\r\n        }\r\n        this._receiver = null;\r\n        this.isConnected = false;\r\n\r\n        if (didDisconnect) {\r\n            this.disconnected(this, e || TransportDisconnectedEvent.Empty);\r\n        }\r\n    }\r\n\r\n    private runReceive(): void {\r\n        this.receivePackets()\r\n            .catch();\r\n    }\r\n\r\n    private async receivePackets(): Promise<void> {\r\n        let isClosed;\r\n\r\n        while (this.isConnected && !isClosed) {\r\n            try {\r\n                let readSoFar = 0;\r\n                while (readSoFar < PayloadConstants.MaxHeaderLength) {\r\n                    this._receiveHeaderBuffer = await this._receiver.receive(PayloadConstants.MaxHeaderLength - readSoFar);\r\n\r\n                    if (this._receiveHeaderBuffer) {\r\n                        readSoFar += this._receiveHeaderBuffer.length;\r\n                    }\r\n                }\r\n\r\n                let header = HeaderSerializer.deserialize(this._receiveHeaderBuffer);\r\n                let isStream = header.payloadType === PayloadTypes.stream;\r\n\r\n                if (header.payloadLength > 0) {\r\n                    let bytesActuallyRead = 0;\r\n\r\n                    let contentStream = this._getStream(header);\r\n\r\n                    while (bytesActuallyRead < header.payloadLength && bytesActuallyRead < PayloadConstants.MaxPayloadLength) {\r\n                        let count = Math.min(header.payloadLength - bytesActuallyRead, PayloadConstants.MaxPayloadLength);\r\n                        this._receivePayloadBuffer = await this._receiver.receive(count);\r\n                        bytesActuallyRead += this._receivePayloadBuffer.byteLength;\r\n                        contentStream.write(this._receivePayloadBuffer);\r\n\r\n                        // If this is a stream we want to keep handing it up as it comes in\r\n                        if (isStream) {\r\n                            this._receiveAction(header, contentStream, bytesActuallyRead);\r\n                        }\r\n                    }\r\n\r\n                    if (!isStream) {\r\n                        this._receiveAction(header, contentStream, bytesActuallyRead);\r\n                    }\r\n                }\r\n            } catch (error) {\r\n                isClosed = true;\r\n                this.disconnect(new TransportDisconnectedEvent(error.message));\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}