{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n  return function (source) {\n    if (count === 0) {\n      return new EmptyObservable_1.EmptyObservable();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\nexports.take = take;\nvar TakeOperator = function () {\n  function TakeOperator(total) {\n    this.total = total;\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();\n    }\n  }\n  TakeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  };\n  return TakeOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeSubscriber = function (_super) {\n  __extends(TakeSubscriber, _super);\n  function TakeSubscriber(destination, total) {\n    _super.call(this, destination);\n    this.total = total;\n    this.count = 0;\n  }\n  TakeSubscriber.prototype._next = function (value) {\n    var total = this.total;\n    var count = ++this.count;\n    if (count <= total) {\n      this.destination.next(value);\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  };\n  return TakeSubscriber;\n}(Subscriber_1.Subscriber);","map":{"version":3,"mappings":";;;;;;;;;AACA,2BAA2B,eAAe,CAAC;AAC3C,wCAAwC,iCAAiC,CAAC;AAC1E,gCAAgC,+BAA+B,CAAC;AAKhE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,cAAwBA,KAAa;EACnC,OAAO,UAACC,MAAqB;IAC3B,IAAID,KAAK,KAAK,CAAC,EAAE;MACf,OAAO,IAAIE,iCAAe,EAAK;IACjC,CAAC,MAAM;MACL,OAAOD,MAAM,CAACE,IAAI,CAAC,IAAIC,YAAY,CAACJ,KAAK,CAAC,CAAC;IAC7C;EACF,CAAC;AACH;AARgBK,YAAI,OAQnB;AAED;EACE,sBAAoBC,KAAa;IAAb,UAAK,GAALA,KAAK;IACvB,IAAI,IAAI,CAACA,KAAK,GAAG,CAAC,EAAE;MAClB,MAAM,IAAIC,iDAAuB;IACnC;EACF;EAEAH,2BAAI,GAAJ,UAAKI,UAAyB,EAAEP,MAAW;IACzC,OAAOA,MAAM,CAACQ,SAAS,CAAC,IAAIC,cAAc,CAACF,UAAU,EAAE,IAAI,CAACF,KAAK,CAAC,CAAC;EACrE,CAAC;EACH,mBAAC;AAAD,CAAC,EAVD;AAYA;;;;;AAKA;EAAgCK;EAG9B,wBAAYC,WAA0B,EAAUN,KAAa;IAC3DO,kBAAMD,WAAW,CAAC;IAD4B,UAAK,GAALN,KAAK;IAF7C,UAAK,GAAW,CAAC;EAIzB;EAEUI,8BAAK,GAAf,UAAgBI,KAAQ;IACtB,IAAMR,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,IAAMN,KAAK,GAAG,EAAE,IAAI,CAACA,KAAK;IAC1B,IAAIA,KAAK,IAAIM,KAAK,EAAE;MAClB,IAAI,CAACM,WAAW,CAACG,IAAI,CAACD,KAAK,CAAC;MAC5B,IAAId,KAAK,KAAKM,KAAK,EAAE;QACnB,IAAI,CAACM,WAAW,CAACI,QAAQ,EAAE;QAC3B,IAAI,CAACC,WAAW,EAAE;MACpB;IACF;EACF,CAAC;EACH,qBAAC;AAAD,CAAC,CAlB+BC,uBAAU","names":["count","source","EmptyObservable_1","lift","TakeOperator","exports","total","ArgumentOutOfRangeError_1","subscriber","subscribe","TakeSubscriber","__extends","destination","_super","value","next","complete","unsubscribe","Subscriber_1"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\src\\operators\\take.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { EmptyObservable } from '../observable/EmptyObservable';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return new EmptyObservable<T>();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nclass TakeOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const total = this.total;\n    const count = ++this.count;\n    if (count <= total) {\n      this.destination.next(value);\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}