{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/esnext.promise.try.js\");\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"DirectLineStreaming\", {\n  enumerable: true,\n  get: function get() {\n    return _directLineStreaming.DirectLineStreaming;\n  }\n});\nexports.DirectLine = exports.ConnectionStatus = void 0;\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nrequire(\"url-search-params-polyfill\");\nvar _BehaviorSubject = require(\"rxjs/BehaviorSubject\");\nvar _Observable = require(\"rxjs/Observable\");\nvar _async = require(\"rxjs/scheduler/async\");\nrequire(\"rxjs/add/operator/catch\");\nrequire(\"rxjs/add/operator/combineLatest\");\nrequire(\"rxjs/add/operator/count\");\nrequire(\"rxjs/add/operator/delay\");\nrequire(\"rxjs/add/operator/do\");\nrequire(\"rxjs/add/operator/filter\");\nrequire(\"rxjs/add/operator/map\");\nrequire(\"rxjs/add/operator/mergeMap\");\nrequire(\"rxjs/add/operator/concatMap\");\nrequire(\"rxjs/add/operator/retryWhen\");\nrequire(\"rxjs/add/operator/share\");\nrequire(\"rxjs/add/operator/take\");\nrequire(\"rxjs/add/observable/dom/ajax\");\nrequire(\"rxjs/add/observable/empty\");\nrequire(\"rxjs/add/observable/from\");\nrequire(\"rxjs/add/observable/interval\");\nrequire(\"rxjs/add/observable/of\");\nrequire(\"rxjs/add/observable/throw\");\nvar _dedupeFilenames = _interopRequireDefault(require(\"./dedupeFilenames\"));\nvar _directLineStreaming = require(\"./directLineStreaming\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar DIRECT_LINE_VERSION = 'DirectLine/3.0';\n// These types are specific to this client library, not to Direct Line 3.0\nvar ConnectionStatus;\nexports.ConnectionStatus = ConnectionStatus;\n(function (ConnectionStatus) {\n  ConnectionStatus[ConnectionStatus[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  ConnectionStatus[ConnectionStatus[\"Connecting\"] = 1] = \"Connecting\";\n  ConnectionStatus[ConnectionStatus[\"Online\"] = 2] = \"Online\";\n  ConnectionStatus[ConnectionStatus[\"ExpiredToken\"] = 3] = \"ExpiredToken\";\n  ConnectionStatus[ConnectionStatus[\"FailedToConnect\"] = 4] = \"FailedToConnect\";\n  ConnectionStatus[ConnectionStatus[\"Ended\"] = 5] = \"Ended\";\n})(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));\nvar wrapAjaxWithRetry = function wrapAjaxWithRetry(source, scheduler) {\n  var notImplemented = function notImplemented() {\n    throw new Error('not implemented');\n  };\n  var inner = function inner(response$) {\n    return response$[\"catch\"](function (err) {\n      if (err.status === 429) {\n        var retryAfterValue = err.xhr.getResponseHeader('Retry-After');\n        var retryAfter = Number(retryAfterValue);\n        if (!isNaN(retryAfter)) {\n          return _Observable.Observable.timer(retryAfter, scheduler).flatMap(function (_) {\n            return _Observable.Observable[\"throw\"](err, scheduler);\n          });\n        }\n      }\n      return _Observable.Observable[\"throw\"](err, scheduler);\n    });\n  };\n  var outer = function outer(urlOrRequest) {\n    return inner(source(urlOrRequest));\n  };\n  return Object.assign(outer, {\n    get: function get(url, headers) {\n      return notImplemented();\n    },\n    post: function post(url, body, headers) {\n      return notImplemented();\n    },\n    put: function put(url, body, headers) {\n      return notImplemented();\n    },\n    patch: function patch(url, body, headers) {\n      return notImplemented();\n    },\n    \"delete\": function _delete(url, headers) {\n      return notImplemented();\n    },\n    getJSON: function getJSON(url, headers) {\n      return notImplemented();\n    }\n  });\n};\nvar makeServices = function makeServices(services) {\n  var scheduler = services.scheduler || _async.async;\n  return {\n    scheduler: scheduler,\n    ajax: wrapAjaxWithRetry(services.ajax || _Observable.Observable.ajax, scheduler),\n    WebSocket: services.WebSocket || WebSocket,\n    random: services.random || Math.random\n  };\n};\nvar lifetimeRefreshToken = 30 * 60 * 1000;\nvar intervalRefreshToken = lifetimeRefreshToken / 2;\nvar POLLING_INTERVAL_LOWER_BOUND = 200; //ms\n\nvar errorExpiredToken = new Error(\"expired token\");\nvar errorConversationEnded = new Error(\"conversation ended\");\nvar errorFailedToConnect = new Error(\"failed to connect\");\nvar konsole = {\n  log: function log(message) {\n    var _console;\n    for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      optionalParams[_key - 1] = arguments[_key];\n    }\n    if (typeof window !== 'undefined' && window[\"botchatDebug\"] && message) (_console = console).log.apply(_console, [message].concat(optionalParams));\n  }\n};\nvar DirectLine = /*#__PURE__*/\nfunction () {\n  //ms\n  function DirectLine(options) {\n    (0, _classCallCheck2[\"default\"])(this, DirectLine);\n    (0, _defineProperty2[\"default\"])(this, \"connectionStatus$\", new _BehaviorSubject.BehaviorSubject(ConnectionStatus.Uninitialized));\n    (0, _defineProperty2[\"default\"])(this, \"activity$\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"domain\", \"https://directline.botframework.com/v3/directline\");\n    (0, _defineProperty2[\"default\"])(this, \"webSocket\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"conversationId\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"expiredTokenExhaustion\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"secret\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"token\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"watermark\", '');\n    (0, _defineProperty2[\"default\"])(this, \"streamUrl\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"_botAgent\", '');\n    (0, _defineProperty2[\"default\"])(this, \"services\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"_userAgent\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"referenceGrammarId\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"timeout\", 20 * 1000);\n    (0, _defineProperty2[\"default\"])(this, \"retries\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"localeOnStartConversation\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"pollingInterval\", 1000);\n    (0, _defineProperty2[\"default\"])(this, \"tokenRefreshSubscription\", void 0);\n    this.secret = options.secret;\n    this.token = options.secret || options.token;\n    this.webSocket = (options.webSocket === undefined ? true : options.webSocket) && typeof WebSocket !== 'undefined' && WebSocket !== undefined;\n    if (options.conversationStartProperties && options.conversationStartProperties.locale) {\n      if (Object.prototype.toString.call(options.conversationStartProperties.locale) === '[object String]') {\n        this.localeOnStartConversation = options.conversationStartProperties.locale;\n      } else {\n        console.warn('DirectLineJS: conversationStartProperties.locale was ignored: the locale name may be a BCP 47 language tag');\n      }\n    }\n    if (options.domain) {\n      this.domain = options.domain;\n    }\n    if (options.conversationId) {\n      this.conversationId = options.conversationId;\n    }\n    if (options.watermark) {\n      this.watermark = options.watermark;\n    }\n    if (options.streamUrl) {\n      if (options.token && options.conversationId) {\n        this.streamUrl = options.streamUrl;\n      } else {\n        console.warn('DirectLineJS: streamUrl was ignored: you need to provide a token and a conversationid');\n      }\n    }\n    if (options.timeout !== undefined) {\n      this.timeout = options.timeout;\n    }\n    this.retries = (lifetimeRefreshToken - intervalRefreshToken) / this.timeout;\n    this._botAgent = this.getBotAgent(options.botAgent);\n    this.services = makeServices(options);\n    var parsedPollingInterval = ~~options.pollingInterval;\n    if (parsedPollingInterval < POLLING_INTERVAL_LOWER_BOUND) {\n      if (typeof options.pollingInterval !== 'undefined') {\n        console.warn(\"DirectLineJS: provided pollingInterval (\".concat(options.pollingInterval, \") is under lower bound (200ms), using default of 1000ms\"));\n      }\n    } else {\n      this.pollingInterval = parsedPollingInterval;\n    }\n    this.expiredTokenExhaustion = this.setConnectionStatusFallback(ConnectionStatus.ExpiredToken, ConnectionStatus.FailedToConnect, 5);\n    this.activity$ = (this.webSocket ? this.webSocketActivity$() : this.pollingGetActivity$()).share();\n  } // Every time we're about to make a Direct Line REST call, we call this first to see check the current connection status.\n  // Either throws an error (indicating an error state) or emits a null, indicating a (presumably) healthy connection\n\n  (0, _createClass2[\"default\"])(DirectLine, [{\n    key: \"checkConnection\",\n    value: function checkConnection() {\n      var _this = this;\n      var once = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var obs = this.connectionStatus$.flatMap(function (connectionStatus) {\n        if (connectionStatus === ConnectionStatus.Uninitialized) {\n          _this.connectionStatus$.next(ConnectionStatus.Connecting); //if token and streamUrl are defined it means reconnect has already been done. Skipping it.\n\n          if (_this.token && _this.streamUrl) {\n            _this.connectionStatus$.next(ConnectionStatus.Online);\n            return _Observable.Observable.of(connectionStatus, _this.services.scheduler);\n          } else {\n            return _this.startConversation()[\"do\"](function (conversation) {\n              _this.conversationId = conversation.conversationId;\n              _this.token = _this.secret || conversation.token;\n              _this.streamUrl = conversation.streamUrl;\n              _this.referenceGrammarId = conversation.referenceGrammarId;\n              if (!_this.secret) _this.refreshTokenLoop();\n              _this.connectionStatus$.next(ConnectionStatus.Online);\n            }, function (error) {\n              _this.connectionStatus$.next(ConnectionStatus.FailedToConnect);\n            }).map(function (_) {\n              return connectionStatus;\n            });\n          }\n        } else {\n          return _Observable.Observable.of(connectionStatus, _this.services.scheduler);\n        }\n      }).filter(function (connectionStatus) {\n        return connectionStatus != ConnectionStatus.Uninitialized && connectionStatus != ConnectionStatus.Connecting;\n      }).flatMap(function (connectionStatus) {\n        switch (connectionStatus) {\n          case ConnectionStatus.Ended:\n            return _Observable.Observable[\"throw\"](errorConversationEnded, _this.services.scheduler);\n          case ConnectionStatus.FailedToConnect:\n            return _Observable.Observable[\"throw\"](errorFailedToConnect, _this.services.scheduler);\n          case ConnectionStatus.ExpiredToken:\n            return _Observable.Observable.of(connectionStatus, _this.services.scheduler);\n          default:\n            return _Observable.Observable.of(connectionStatus, _this.services.scheduler);\n        }\n      });\n      return once ? obs.take(1) : obs;\n    }\n  }, {\n    key: \"setConnectionStatusFallback\",\n    value: function setConnectionStatusFallback(connectionStatusFrom, connectionStatusTo) {\n      var maxAttempts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n      maxAttempts--;\n      var attempts = 0;\n      var currStatus = null;\n      return function (status) {\n        if (status === connectionStatusFrom && currStatus === status && attempts >= maxAttempts) {\n          attempts = 0;\n          return connectionStatusTo;\n        }\n        attempts++;\n        currStatus = status;\n        return status;\n      };\n    }\n  }, {\n    key: \"expiredToken\",\n    value: function expiredToken() {\n      var connectionStatus = this.connectionStatus$.getValue();\n      if (connectionStatus != ConnectionStatus.Ended && connectionStatus != ConnectionStatus.FailedToConnect) this.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n      var protectedConnectionStatus = this.expiredTokenExhaustion(this.connectionStatus$.getValue());\n      this.connectionStatus$.next(protectedConnectionStatus);\n    }\n  }, {\n    key: \"startConversation\",\n    value: function startConversation() {\n      var _this2 = this;\n\n      //if conversationid is set here, it means we need to call the reconnect api, else it is a new conversation\n      var url = this.conversationId ? \"\".concat(this.domain, \"/conversations/\").concat(this.conversationId, \"?watermark=\").concat(this.watermark) : \"\".concat(this.domain, \"/conversations\");\n      var method = this.conversationId ? \"GET\" : \"POST\";\n      var body = this.conversationId ? undefined : {\n        locale: this.localeOnStartConversation\n      };\n      return this.services.ajax({\n        method: method,\n        url: url,\n        body: body,\n        timeout: this.timeout,\n        headers: _objectSpread({\n          \"Accept\": \"application/json\",\n          \"Content-Type\": \"application/json\"\n        }, this.commonHeaders())\n      }) //      .do(ajaxResponse => konsole.log(\"conversation ajaxResponse\", ajaxResponse.response))\n      .map(function (ajaxResponse) {\n        return ajaxResponse.response;\n      }).retryWhen(function (error$) {\n        return (\n          // for now we deem 4xx and 5xx errors as unrecoverable\n          // for everything else (timeouts), retry for a while\n          error$.mergeMap(function (error) {\n            return error.status >= 400 && error.status < 600 ? _Observable.Observable[\"throw\"](error, _this2.services.scheduler) : _Observable.Observable.of(error, _this2.services.scheduler);\n          }).delay(_this2.timeout, _this2.services.scheduler).take(_this2.retries)\n        );\n      });\n    }\n  }, {\n    key: \"refreshTokenLoop\",\n    value: function refreshTokenLoop() {\n      var _this3 = this;\n      this.tokenRefreshSubscription = _Observable.Observable.interval(intervalRefreshToken, this.services.scheduler).flatMap(function (_) {\n        return _this3.refreshToken();\n      }).subscribe(function (token) {\n        konsole.log(\"refreshing token\", token, \"at\", new Date());\n        _this3.token = token;\n      });\n    }\n  }, {\n    key: \"refreshToken\",\n    value: function refreshToken() {\n      var _this4 = this;\n      return this.checkConnection(true).flatMap(function (_) {\n        return _this4.services.ajax({\n          method: \"POST\",\n          url: \"\".concat(_this4.domain, \"/tokens/refresh\"),\n          timeout: _this4.timeout,\n          headers: _objectSpread({}, _this4.commonHeaders())\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response.token;\n        }).retryWhen(function (error$) {\n          return error$.mergeMap(function (error) {\n            if (error.status === 403) {\n              // if the token is expired there's no reason to keep trying\n              _this4.expiredToken();\n              return _Observable.Observable[\"throw\"](error, _this4.services.scheduler);\n            } else if (error.status === 404) {\n              // If the bot is gone, we should stop retrying\n              return _Observable.Observable[\"throw\"](error, _this4.services.scheduler);\n            }\n            return _Observable.Observable.of(error, _this4.services.scheduler);\n          }).delay(_this4.timeout, _this4.services.scheduler).take(_this4.retries);\n        });\n      });\n    }\n  }, {\n    key: \"reconnect\",\n    value: function reconnect(conversation) {\n      this.token = conversation.token;\n      this.streamUrl = conversation.streamUrl;\n      if (this.connectionStatus$.getValue() === ConnectionStatus.ExpiredToken) this.connectionStatus$.next(ConnectionStatus.Online);\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this.tokenRefreshSubscription) this.tokenRefreshSubscription.unsubscribe();\n      try {\n        this.connectionStatus$.next(ConnectionStatus.Ended);\n      } catch (e) {\n        if (e === errorConversationEnded) return;\n        throw e;\n      }\n    }\n  }, {\n    key: \"getSessionId\",\n    value: function getSessionId() {\n      var _this5 = this;\n\n      // If we're not connected to the bot, get connected\n      // Will throw an error if we are not connected\n      konsole.log(\"getSessionId\");\n      return this.checkConnection(true).flatMap(function (_) {\n        return _this5.services.ajax({\n          method: \"GET\",\n          url: \"\".concat(_this5.domain, \"/session/getsessionid\"),\n          withCredentials: true,\n          timeout: _this5.timeout,\n          headers: _objectSpread({\n            \"Content-Type\": \"application/json\"\n          }, _this5.commonHeaders())\n        }).map(function (ajaxResponse) {\n          if (ajaxResponse && ajaxResponse.response && ajaxResponse.response.sessionId) {\n            konsole.log(\"getSessionId response: \" + ajaxResponse.response.sessionId);\n            return ajaxResponse.response.sessionId;\n          }\n          return '';\n        })[\"catch\"](function (error) {\n          konsole.log(\"getSessionId error: \" + error.status);\n          return _Observable.Observable.of('', _this5.services.scheduler);\n        });\n      })[\"catch\"](function (error) {\n        return _this5.catchExpiredToken(error);\n      });\n    }\n  }, {\n    key: \"postActivity\",\n    value: function postActivity(activity) {\n      var _this6 = this;\n\n      // Use postMessageWithAttachments for messages with attachments that are local files (e.g. an image to upload)\n      // Technically we could use it for *all* activities, but postActivity is much lighter weight\n      // So, since WebChat is partially a reference implementation of Direct Line, we implement both.\n      if (activity.type === \"message\" && activity.attachments && activity.attachments.length > 0) return this.postMessageWithAttachments(activity); // If we're not connected to the bot, get connected\n      // Will throw an error if we are not connected\n\n      konsole.log(\"postActivity\", activity);\n      return this.checkConnection(true).flatMap(function (_) {\n        return _this6.services.ajax({\n          method: \"POST\",\n          url: \"\".concat(_this6.domain, \"/conversations/\").concat(_this6.conversationId, \"/activities\"),\n          body: activity,\n          timeout: _this6.timeout,\n          headers: _objectSpread({\n            \"Content-Type\": \"application/json\"\n          }, _this6.commonHeaders())\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response.id;\n        })[\"catch\"](function (error) {\n          return _this6.catchPostError(error);\n        });\n      })[\"catch\"](function (error) {\n        return _this6.catchExpiredToken(error);\n      });\n    }\n  }, {\n    key: \"postMessageWithAttachments\",\n    value: function postMessageWithAttachments(message) {\n      var _this7 = this;\n      var attachments = message.attachments; // We clean the attachments but making sure every attachment has unique name.\n      // If the file do not have a name, Chrome will assign \"blob\" when it is appended to FormData.\n\n      var attachmentNames = (0, _dedupeFilenames[\"default\"])(attachments.map(function (media) {\n        return media.name || 'blob';\n      }));\n      var cleansedAttachments = attachments.map(function (attachment, index) {\n        return _objectSpread({}, attachment, {\n          name: attachmentNames[index]\n        });\n      });\n      var formData; // If we're not connected to the bot, get connected\n      // Will throw an error if we are not connected\n\n      return this.checkConnection(true).flatMap(function (_) {\n        // To send this message to DirectLine we need to deconstruct it into a \"template\" activity\n        // and one blob for each attachment.\n        formData = new FormData();\n        formData.append('activity', new Blob([JSON.stringify(_objectSpread({}, message, {\n          // Removing contentUrl from attachment, we will send it via multipart\n          attachments: cleansedAttachments.map(function (_ref) {\n            var string = _ref.contentUrl,\n              others = (0, _objectWithoutProperties2[\"default\"])(_ref, [\"contentUrl\"]);\n            return _objectSpread({}, others);\n          })\n        }))], {\n          type: 'application/vnd.microsoft.activity'\n        }));\n        return _Observable.Observable.from(cleansedAttachments, _this7.services.scheduler).flatMap(function (media) {\n          return _this7.services.ajax({\n            method: \"GET\",\n            url: media.contentUrl,\n            responseType: 'arraybuffer'\n          })[\"do\"](function (ajaxResponse) {\n            return formData.append('file', new Blob([ajaxResponse.response], {\n              type: media.contentType\n            }), media.name);\n          });\n        }).count();\n      }).flatMap(function (_) {\n        return _this7.services.ajax({\n          method: \"POST\",\n          url: \"\".concat(_this7.domain, \"/conversations/\").concat(_this7.conversationId, \"/upload?userId=\").concat(message.from.id),\n          body: formData,\n          timeout: _this7.timeout,\n          headers: _objectSpread({}, _this7.commonHeaders())\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response.id;\n        })[\"catch\"](function (error) {\n          return _this7.catchPostError(error);\n        });\n      })[\"catch\"](function (error) {\n        return _this7.catchPostError(error);\n      });\n    }\n  }, {\n    key: \"catchPostError\",\n    value: function catchPostError(error) {\n      if (error.status === 403)\n        // token has expired (will fall through to return \"retry\")\n        this.expiredToken();else if (error.status >= 400 && error.status < 500)\n        // more unrecoverable errors\n        return _Observable.Observable[\"throw\"](error, this.services.scheduler);\n      return _Observable.Observable.of(\"retry\", this.services.scheduler);\n    }\n  }, {\n    key: \"catchExpiredToken\",\n    value: function catchExpiredToken(error) {\n      return error === errorExpiredToken ? _Observable.Observable.of(\"retry\", this.services.scheduler) : _Observable.Observable[\"throw\"](error, this.services.scheduler);\n    }\n  }, {\n    key: \"pollingGetActivity$\",\n    value: function pollingGetActivity$() {\n      var _this8 = this;\n      var poller$ = _Observable.Observable.create(function (subscriber) {\n        // A BehaviorSubject to trigger polling. Since it is a BehaviorSubject\n        // the first event is produced immediately.\n        var trigger$ = new _BehaviorSubject.BehaviorSubject({}); // TODO: remove Date.now, use reactive interval to space out every request\n\n        trigger$.subscribe(function () {\n          if (_this8.connectionStatus$.getValue() === ConnectionStatus.Online) {\n            var startTimestamp = Date.now();\n            _this8.services.ajax({\n              headers: _objectSpread({\n                Accept: 'application/json'\n              }, _this8.commonHeaders()),\n              method: 'GET',\n              url: \"\".concat(_this8.domain, \"/conversations/\").concat(_this8.conversationId, \"/activities?watermark=\").concat(_this8.watermark),\n              timeout: _this8.timeout\n            }).subscribe(function (result) {\n              subscriber.next(result);\n              setTimeout(function () {\n                return trigger$.next(null);\n              }, Math.max(0, _this8.pollingInterval - Date.now() + startTimestamp));\n            }, function (error) {\n              switch (error.status) {\n                case 403:\n                  _this8.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n                  setTimeout(function () {\n                    return trigger$.next(null);\n                  }, _this8.pollingInterval);\n                  break;\n                case 404:\n                  _this8.connectionStatus$.next(ConnectionStatus.Ended);\n                  break;\n                default:\n                  // propagate the error\n                  subscriber.error(error);\n                  break;\n              }\n            });\n          }\n        });\n      });\n      return this.checkConnection().flatMap(function (_) {\n        return poller$[\"catch\"](function () {\n          return _Observable.Observable.empty();\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response;\n        }).flatMap(function (activityGroup) {\n          return _this8.observableFromActivityGroup(activityGroup);\n        });\n      });\n    }\n  }, {\n    key: \"observableFromActivityGroup\",\n    value: function observableFromActivityGroup(activityGroup) {\n      if (activityGroup.watermark) this.watermark = activityGroup.watermark;\n      return _Observable.Observable.from(activityGroup.activities, this.services.scheduler);\n    }\n  }, {\n    key: \"webSocketActivity$\",\n    value: function webSocketActivity$() {\n      var _this9 = this;\n      return this.checkConnection().flatMap(function (_) {\n        return _this9.observableWebSocket() // WebSockets can be closed by the server or the browser. In the former case we need to\n        // retrieve a new streamUrl. In the latter case we could first retry with the current streamUrl,\n        // but it's simpler just to always fetch a new one.\n        .retryWhen(function (error$) {\n          return error$.delay(_this9.getRetryDelay(), _this9.services.scheduler).mergeMap(function (error) {\n            return _this9.reconnectToConversation();\n          });\n        });\n      }).flatMap(function (activityGroup) {\n        return _this9.observableFromActivityGroup(activityGroup);\n      });\n    } // Returns the delay duration in milliseconds\n  }, {\n    key: \"getRetryDelay\",\n    value: function getRetryDelay() {\n      return Math.floor(3000 + this.services.random() * 12000);\n    } // Originally we used Observable.webSocket, but it's fairly opinionated and I ended up writing\n    // a lot of code to work around their implementation details. Since WebChat is meant to be a reference\n    // implementation, I decided roll the below, where the logic is more purposeful. - @billba\n  }, {\n    key: \"observableWebSocket\",\n    value: function observableWebSocket() {\n      var _this10 = this;\n      return _Observable.Observable.create(function (subscriber) {\n        konsole.log(\"creating WebSocket\", _this10.streamUrl);\n        var ws = new _this10.services.WebSocket(_this10.streamUrl);\n        var sub;\n        ws.onopen = function (open) {\n          konsole.log(\"WebSocket open\", open); // Chrome is pretty bad at noticing when a WebSocket connection is broken.\n          // If we periodically ping the server with empty messages, it helps Chrome\n          // realize when connection breaks, and close the socket. We then throw an\n          // error, and that give us the opportunity to attempt to reconnect.\n\n          sub = _Observable.Observable.interval(_this10.timeout, _this10.services.scheduler).subscribe(function (_) {\n            try {\n              ws.send(\"\");\n            } catch (e) {\n              konsole.log(\"Ping error\", e);\n            }\n          });\n        };\n        ws.onclose = function (close) {\n          konsole.log(\"WebSocket close\", close);\n          if (sub) sub.unsubscribe();\n          subscriber.error(close);\n        };\n        ws.onmessage = function (message) {\n          return message.data && subscriber.next(JSON.parse(message.data));\n        }; // This is the 'unsubscribe' method, which is called when this observable is disposed.\n        // When the WebSocket closes itself, we throw an error, and this function is eventually called.\n        // When the observable is closed first (e.g. when tearing down a WebChat instance) then\n        // we need to manually close the WebSocket.\n\n        return function () {\n          if (ws.readyState === 0 || ws.readyState === 1) ws.close();\n        };\n      });\n    }\n  }, {\n    key: \"reconnectToConversation\",\n    value: function reconnectToConversation() {\n      var _this11 = this;\n      return this.checkConnection(true).flatMap(function (_) {\n        return _this11.services.ajax({\n          method: \"GET\",\n          url: \"\".concat(_this11.domain, \"/conversations/\").concat(_this11.conversationId, \"?watermark=\").concat(_this11.watermark),\n          timeout: _this11.timeout,\n          headers: _objectSpread({\n            \"Accept\": \"application/json\"\n          }, _this11.commonHeaders())\n        })[\"do\"](function (result) {\n          if (!_this11.secret) _this11.token = result.response.token;\n          _this11.streamUrl = result.response.streamUrl;\n        }).map(function (_) {\n          return null;\n        }).retryWhen(function (error$) {\n          return error$.mergeMap(function (error) {\n            if (error.status === 403) {\n              // token has expired. We can't recover from this here, but the embedding\n              // website might eventually call reconnect() with a new token and streamUrl.\n              _this11.expiredToken();\n            } else if (error.status === 404) {\n              return _Observable.Observable[\"throw\"](errorConversationEnded, _this11.services.scheduler);\n            }\n            return _Observable.Observable.of(error, _this11.services.scheduler);\n          }).delay(_this11.timeout, _this11.services.scheduler).take(_this11.retries);\n        });\n      });\n    }\n  }, {\n    key: \"commonHeaders\",\n    value: function commonHeaders() {\n      return {\n        \"Authorization\": \"Bearer \".concat(this.token),\n        \"x-ms-bot-agent\": this._botAgent\n      };\n    }\n  }, {\n    key: \"getBotAgent\",\n    value: function getBotAgent() {\n      var customAgent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var clientAgent = 'directlinejs';\n      if (customAgent) {\n        clientAgent += \"; \".concat(customAgent);\n      }\n      return \"\".concat(DIRECT_LINE_VERSION, \" (\").concat(clientAgent, \" \").concat(\"0.13.1\", \")\");\n    }\n  }]);\n  return DirectLine;\n}();\nexports.DirectLine = DirectLine;","map":{"version":3,"mappings":"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","names":["require","DIRECT_LINE_VERSION","ConnectionStatus","wrapAjaxWithRetry","source","scheduler","notImplemented","Error","inner","response$","err","status","retryAfterValue","xhr","getResponseHeader","retryAfter","Number","isNaN","Observable","timer","flatMap","outer","urlOrRequest","Object","assign","get","url","headers","post","body","put","patch","getJSON","makeServices","services","AsyncScheduler","ajax","WebSocket","random","Math","lifetimeRefreshToken","intervalRefreshToken","POLLING_INTERVAL_LOWER_BOUND","errorExpiredToken","errorConversationEnded","errorFailedToConnect","konsole","log","message","optionalParams","window","DirectLine","options","BehaviorSubject","Uninitialized","secret","token","webSocket","undefined","conversationStartProperties","locale","prototype","toString","call","localeOnStartConversation","console","warn","domain","conversationId","watermark","streamUrl","timeout","retries","_botAgent","getBotAgent","botAgent","parsedPollingInterval","pollingInterval","expiredTokenExhaustion","setConnectionStatusFallback","ExpiredToken","FailedToConnect","activity$","webSocketActivity$","pollingGetActivity$","share","once","obs","connectionStatus$","connectionStatus","_this","next","Connecting","Online","of","startConversation","conversation","referenceGrammarId","refreshTokenLoop","map","filter","Ended","take","connectionStatusFrom","connectionStatusTo","maxAttempts","attempts","currStatus","getValue","protectedConnectionStatus","method","commonHeaders","ajaxResponse","response","retryWhen","error$","mergeMap","error","_this2","delay","tokenRefreshSubscription","interval","_this3","refreshToken","subscribe","Date","checkConnection","_this4","expiredToken","unsubscribe","e","_this5","withCredentials","sessionId","catchExpiredToken","activity","type","attachments","length","postMessageWithAttachments","_this6","id","catchPostError","attachmentNames","media","name","cleansedAttachments","attachment","index","formData","FormData","append","Blob","JSON","stringify","string","contentUrl","others","from","_this7","responseType","contentType","count","poller$","create","subscriber","trigger$","_this8","startTimestamp","now","Accept","result","setTimeout","max","empty","observableFromActivityGroup","activityGroup","activities","_this9","observableWebSocket","getRetryDelay","reconnectToConversation","floor","_this10","ws","sub","onopen","open","send","onclose","close","onmessage","data","parse","readyState","_this11","customAgent","clientAgent"],"sources":["C:\\Projects\\health-care-chatbot\\node_modules\\botframework-directlinejs\\src\\directLine.ts"],"sourcesContent":["// In order to keep file size down, only import the parts of rxjs that we use\n\nimport 'core-js/features/promise';\nimport 'url-search-params-polyfill';\nimport { AjaxResponse, AjaxCreationMethod, AjaxRequest, AjaxError } from 'rxjs/observable/dom/AjaxObservable';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { IScheduler } from 'rxjs/Scheduler';\nimport { Subscriber } from 'rxjs/Subscriber';\nimport { Subscription } from 'rxjs/Subscription';\nimport { async as AsyncScheduler } from 'rxjs/scheduler/async';\n\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/combineLatest';\nimport 'rxjs/add/operator/count';\nimport 'rxjs/add/operator/delay';\nimport 'rxjs/add/operator/do';\nimport 'rxjs/add/operator/filter';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/mergeMap';\nimport 'rxjs/add/operator/concatMap';\nimport 'rxjs/add/operator/retryWhen';\nimport 'rxjs/add/operator/share';\nimport 'rxjs/add/operator/take';\n\nimport 'rxjs/add/observable/dom/ajax';\nimport 'rxjs/add/observable/empty';\nimport 'rxjs/add/observable/from';\nimport 'rxjs/add/observable/interval';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/observable/throw';\n\nimport dedupeFilenames from './dedupeFilenames';\nimport { objectExpression } from '@babel/types';\n\nimport { DirectLineStreaming } from './directLineStreaming';\nexport { DirectLineStreaming };\n\nconst DIRECT_LINE_VERSION = 'DirectLine/3.0';\n\ndeclare var process: {\n    arch: string;\n    env: {\n        VERSION: string;\n        npm_package_version: string;\n    };\n    platform: string;\n    release: string;\n    version: string;\n};\n\n// Direct Line 3.0 types\n\nexport interface Conversation {\n    conversationId: string,\n    token: string,\n    eTag?: string,\n    streamUrl?: string,\n    referenceGrammarId?: string\n}\n\nexport type MediaType = \"image/png\" | \"image/jpg\" | \"image/jpeg\" | \"image/gif\" | \"image/svg+xml\" | \"audio/mpeg\" | \"audio/mp4\" | \"video/mp4\";\n\nexport interface Media {\n    contentType: MediaType,\n    contentUrl: string,\n    name?: string,\n    thumbnailUrl?: string\n}\n\nexport interface UnknownMedia{\n    contentType: string,\n    contentUrl: string,\n    name?: string,\n    thumbnailUrl?: string\n}\n\nexport type CardActionTypes = \"call\" | \"downloadFile\"| \"imBack\" | \"messageBack\" | \"openUrl\" | \"playAudio\" | \"playVideo\" | \"postBack\" | \"signin\" | \"showImage\";\n\nexport type CardAction = CallCardAction | DownloadFileCardAction | IMBackCardAction | MessageBackCardAction | OpenURLCardAction | PlayAudioCardAction | PlayVideoCardAction | PostBackCardAction | SignInCardAction | ShowImageCardAction;\n\nexport interface CallCardAction {\n    image?: string,\n    title: string,\n    type: \"call\",\n    value: any\n}\n\nexport interface DownloadFileCardAction {\n    image?: string,\n    title: string,\n    type: \"downloadFile\",\n    value: any\n}\n\nexport interface IMBackCardAction {\n    image?: string,\n    title?: string,\n    type: \"imBack\",\n    value: string\n}\n\nexport type MessageBackCardAction = MessageBackWithImage | MessageBackWithTitle\n\nexport interface MessageBackWithImage {\n    displayText?: string,\n    image: string,\n    text?: string,\n    title?: string,\n    type: \"messageBack\",\n    value?: any\n}\n\nexport interface MessageBackWithTitle {\n    displayText?: string,\n    image?: string,\n    text?: string,\n    title: string,\n    type: \"messageBack\",\n    value?: any\n}\n\nexport interface OpenURLCardAction {\n    image?: string,\n    title: string,\n    type: \"openUrl\",\n    value: any\n}\n\nexport interface PlayAudioCardAction {\n    image?: string,\n    title: string,\n    type: \"playAudio\",\n    value: any\n}\n\nexport interface PlayVideoCardAction {\n    image?: string,\n    title: string,\n    type: \"playVideo\",\n    value: any\n}\n\nexport interface PostBackCardAction {\n    image?: string,\n    title?: string,\n    type: \"postBack\",\n    value: any\n}\n\nexport interface ShowImageCardAction {\n    image?: string,\n    title: string,\n    type: \"showImage\",\n    value: any\n}\n\nexport interface SignInCardAction {\n    image?: string,\n    title: string,\n    type: \"signin\",\n    value: any\n}\n\nexport interface CardImage {\n    alt?: string,\n    url: string,\n    tap?: CardAction\n}\n\nexport interface HeroCard {\n    contentType: \"application/vnd.microsoft.card.hero\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        images?: CardImage[],\n        buttons?: CardAction[],\n        tap?: CardAction\n    }\n}\n\nexport interface Thumbnail {\n    contentType: \"application/vnd.microsoft.card.thumbnail\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        images?: CardImage[],\n        buttons?: CardAction[],\n        tap?: CardAction\n    }\n}\n\nexport interface Signin {\n    contentType: \"application/vnd.microsoft.card.signin\",\n    content: {\n        text?: string,\n        buttons?: CardAction[]\n    }\n}\n\nexport interface OAuth {\n    contentType: \"application/vnd.microsoft.card.oauth\",\n    content: {\n        text?: string,\n        connectionname: string,\n        buttons?: CardAction[]\n    }\n}\n\nexport interface ReceiptItem {\n    title?: string,\n    subtitle?: string,\n    text?: string,\n    image?: CardImage,\n    price?: string,\n    quantity?: string,\n    tap?: CardAction\n}\n\nexport interface Receipt {\n    contentType: \"application/vnd.microsoft.card.receipt\",\n    content: {\n        title?: string,\n        facts?: { key: string, value: string }[],\n        items?: ReceiptItem[],\n        tap?: CardAction,\n        tax?: string,\n        vat?: string,\n        total?: string,\n        buttons?: CardAction[]\n    }\n}\n\n// Deprecated format for Skype channels. For testing legacy bots in Emulator only.\nexport interface FlexCard {\n    contentType: \"application/vnd.microsoft.card.flex\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        images?: CardImage[],\n        buttons?: CardAction[],\n        aspect?: string\n    }\n}\n\nexport interface AudioCard {\n    contentType: \"application/vnd.microsoft.card.audio\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        media?: { url: string, profile?: string }[],\n        buttons?: CardAction[],\n        autoloop?: boolean,\n        autostart?: boolean\n    }\n}\n\nexport interface VideoCard {\n    contentType: \"application/vnd.microsoft.card.video\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        media?: { url: string, profile?: string }[],\n        buttons?: CardAction[],\n        image?: { url: string, alt?: string },\n        autoloop?: boolean,\n        autostart?: boolean\n    }\n}\n\nexport interface AdaptiveCard {\n    contentType: \"application/vnd.microsoft.card.adaptive\",\n    content: any;\n}\n\nexport interface AnimationCard {\n    contentType: \"application/vnd.microsoft.card.animation\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        media?: { url: string, profile?: string }[],\n        buttons?: CardAction[],\n        image?: { url: string, alt?: string },\n        autoloop?: boolean,\n        autostart?: boolean\n    }\n}\n\nexport type KnownMedia = Media | HeroCard | Thumbnail | Signin | OAuth | Receipt | AudioCard | VideoCard | AnimationCard | FlexCard | AdaptiveCard;\nexport type Attachment = KnownMedia | UnknownMedia;\n\nexport type UserRole = \"bot\" | \"channel\" | \"user\";\n\nexport interface User {\n    id: string,\n    name?: string,\n    iconUrl?: string,\n    role?: UserRole\n}\n\nexport interface IActivity {\n    type: string,\n    channelData?: any,\n    channelId?: string,\n    conversation?: { id: string },\n    eTag?: string,\n    from: User,\n    id?: string,\n    timestamp?: string\n}\n\nexport type AttachmentLayout = \"list\" | \"carousel\";\n\nexport interface Message extends IActivity {\n    type: \"message\",\n    text?: string,\n    locale?: string,\n    textFormat?: \"plain\" | \"markdown\" | \"xml\",\n    attachmentLayout?: AttachmentLayout,\n    attachments?: Attachment[],\n    entities?: any[],\n    suggestedActions?: { actions: CardAction[], to?: string[] },\n    speak?: string,\n    inputHint?: string,\n    value?: object\n}\n\nexport interface Typing extends IActivity {\n    type: \"typing\"\n}\n\nexport interface EventActivity extends IActivity {\n    type: \"event\",\n    name: string,\n    value: any\n}\n\nexport type Activity = Message | Typing | EventActivity;\n\nexport interface ActivityGroup {\n    activities: Activity[],\n    watermark: string\n}\n\n// These types are specific to this client library, not to Direct Line 3.0\n\nexport enum ConnectionStatus {\n    Uninitialized,              // the status when the DirectLine object is first created/constructed\n    Connecting,                 // currently trying to connect to the conversation\n    Online,                     // successfully connected to the conversation. Connection is healthy so far as we know.\n    ExpiredToken,               // last operation errored out with an expired token. Possibly waiting for someone to supply a new one.\n    FailedToConnect,            // the initial attempt to connect to the conversation failed. No recovery possible.\n    Ended                       // the bot ended the conversation\n}\n\nexport interface DirectLineOptions {\n    secret?: string,\n    token?: string,\n    conversationId?: string,\n    watermark?: string,\n    domain?: string,\n    webSocket?: boolean,\n    pollingInterval?: number,\n    streamUrl?: string,\n    timeout?: number,\n    // Attached to all requests to identify requesting agent.\n    botAgent?: string,\n    conversationStartProperties?: any\n}\n\nexport interface Services {\n    scheduler: IScheduler;\n    WebSocket: typeof WebSocket;\n    ajax: AjaxCreationMethod;\n    random: () => number;\n}\n\nconst wrapAjaxWithRetry = (source: AjaxCreationMethod, scheduler: IScheduler): AjaxCreationMethod =>{\n\n    const notImplemented = (): never => { throw new Error('not implemented'); };\n\n    const inner = (response$ : Observable<AjaxResponse>) => {\n        return response$\n        .catch<AjaxResponse, AjaxResponse>((err) => {\n            if(err.status === 429){\n                const retryAfterValue = err.xhr.getResponseHeader('Retry-After');\n                const retryAfter = Number(retryAfterValue);\n                if(!isNaN(retryAfter)){\n                    return Observable.timer(retryAfter, scheduler)\n                    .flatMap(_ => Observable.throw(err, scheduler));\n                }\n            }\n\n            return Observable.throw(err, scheduler);\n        });\n    };\n\n    const outer = (urlOrRequest: string| AjaxRequest) => {\n        return inner(source(urlOrRequest));\n    };\n\n    return Object.assign(outer, {\n        get: (url: string, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        post: (url: string, body?: any, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        put: (url: string, body?: any, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        patch: (url: string, body?: any, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        delete: (url: string, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        getJSON: <T>(url: string, headers?: Object): Observable<T> => notImplemented()\n    });\n}\n\nconst makeServices = (services: Partial<Services>): Services => {\n    const scheduler = services.scheduler || AsyncScheduler;\n    return {\n        scheduler,\n        ajax: wrapAjaxWithRetry(services.ajax || Observable.ajax, scheduler),\n        WebSocket: services.WebSocket || WebSocket,\n        random: services.random || Math.random,\n    }\n}\n\nconst lifetimeRefreshToken = 30 * 60 * 1000;\nconst intervalRefreshToken = lifetimeRefreshToken / 2;\n\nconst POLLING_INTERVAL_LOWER_BOUND: number = 200; //ms\n\nconst errorExpiredToken = new Error(\"expired token\");\nconst errorConversationEnded = new Error(\"conversation ended\");\nconst errorFailedToConnect = new Error(\"failed to connect\");\n\nconst konsole = {\n    log: (message?: any, ... optionalParams: any[]) => {\n        if (typeof window !== 'undefined' && (window as any)[\"botchatDebug\"] && message)\n            console.log(message, ... optionalParams);\n    }\n}\n\nexport interface IBotConnection {\n    connectionStatus$: BehaviorSubject<ConnectionStatus>,\n    activity$: Observable<Activity>,\n    end(): void,\n    referenceGrammarId?: string,\n    postActivity(activity: Activity): Observable<string>,\n    getSessionId? : () => Observable<string>\n}\n\nexport class DirectLine implements IBotConnection {\n    public connectionStatus$ = new BehaviorSubject(ConnectionStatus.Uninitialized);\n    public activity$: Observable<Activity>;\n\n    private domain = \"https://directline.botframework.com/v3/directline\";\n    private webSocket: boolean;\n\n    private conversationId: string;\n    private expiredTokenExhaustion: Function;\n    private secret: string;\n    private token: string;\n    private watermark = '';\n    private streamUrl: string;\n    private _botAgent = '';\n    private services: Services;\n    private _userAgent: string;\n    public referenceGrammarId: string;\n    private timeout = 20 * 1000;\n    private retries: number;\n\n    private localeOnStartConversation: string;\n\n    private pollingInterval: number = 1000; //ms\n\n    private tokenRefreshSubscription: Subscription;\n\n    constructor(options: DirectLineOptions & Partial<Services>) {\n        this.secret = options.secret;\n        this.token = options.secret || options.token;\n        this.webSocket = (options.webSocket === undefined ? true : options.webSocket) && typeof WebSocket !== 'undefined' && WebSocket !== undefined;\n\n        if (options.conversationStartProperties && options.conversationStartProperties.locale) {\n            if (Object.prototype.toString.call(options.conversationStartProperties.locale) === '[object String]') {\n                this.localeOnStartConversation = options.conversationStartProperties.locale;\n            } else {\n                console.warn('DirectLineJS: conversationStartProperties.locale was ignored: the locale name may be a BCP 47 language tag');\n            }\n        }\n\n        if (options.domain) {\n            this.domain = options.domain;\n        }\n\n        if (options.conversationId) {\n            this.conversationId = options.conversationId;\n        }\n\n        if (options.watermark) {\n            this.watermark =  options.watermark;\n        }\n\n        if (options.streamUrl) {\n            if (options.token && options.conversationId) {\n                this.streamUrl = options.streamUrl;\n            } else {\n                console.warn('DirectLineJS: streamUrl was ignored: you need to provide a token and a conversationid');\n            }\n        }\n\n        if (options.timeout !== undefined) {\n            this.timeout = options.timeout;\n        }\n\n        this.retries = (lifetimeRefreshToken - intervalRefreshToken) / this.timeout;\n\n        this._botAgent = this.getBotAgent(options.botAgent);\n\n        this.services = makeServices(options);\n\n        const parsedPollingInterval = ~~options.pollingInterval;\n\n        if (parsedPollingInterval < POLLING_INTERVAL_LOWER_BOUND) {\n            if (typeof options.pollingInterval !== 'undefined') {\n                console.warn(`DirectLineJS: provided pollingInterval (${ options.pollingInterval }) is under lower bound (200ms), using default of 1000ms`);\n            }\n        } else {\n            this.pollingInterval = parsedPollingInterval;\n        }\n\n        this.expiredTokenExhaustion = this.setConnectionStatusFallback(\n            ConnectionStatus.ExpiredToken,\n            ConnectionStatus.FailedToConnect,\n            5\n        );\n\n        this.activity$ = (this.webSocket\n            ? this.webSocketActivity$()\n            : this.pollingGetActivity$()\n        ).share();\n    }\n\n    // Every time we're about to make a Direct Line REST call, we call this first to see check the current connection status.\n    // Either throws an error (indicating an error state) or emits a null, indicating a (presumably) healthy connection\n    private checkConnection(once = false) {\n        let obs =  this.connectionStatus$\n        .flatMap(connectionStatus => {\n            if (connectionStatus === ConnectionStatus.Uninitialized) {\n                this.connectionStatus$.next(ConnectionStatus.Connecting);\n\n                //if token and streamUrl are defined it means reconnect has already been done. Skipping it.\n                if (this.token && this.streamUrl) {\n                    this.connectionStatus$.next(ConnectionStatus.Online);\n                    return Observable.of(connectionStatus, this.services.scheduler);\n                } else {\n                    return this.startConversation().do(conversation => {\n                        this.conversationId = conversation.conversationId;\n                        this.token = this.secret || conversation.token;\n                        this.streamUrl = conversation.streamUrl;\n                        this.referenceGrammarId = conversation.referenceGrammarId;\n                        if (!this.secret)\n                            this.refreshTokenLoop();\n\n                        this.connectionStatus$.next(ConnectionStatus.Online);\n                    }, error => {\n                        this.connectionStatus$.next(ConnectionStatus.FailedToConnect);\n                    })\n                    .map(_ => connectionStatus);\n                }\n            }\n            else {\n                return Observable.of(connectionStatus, this.services.scheduler);\n            }\n        })\n        .filter(connectionStatus => connectionStatus != ConnectionStatus.Uninitialized && connectionStatus != ConnectionStatus.Connecting)\n        .flatMap(connectionStatus => {\n            switch (connectionStatus) {\n                case ConnectionStatus.Ended:\n                    return Observable.throw(errorConversationEnded, this.services.scheduler);\n\n                case ConnectionStatus.FailedToConnect:\n                    return Observable.throw(errorFailedToConnect, this.services.scheduler);\n\n                case ConnectionStatus.ExpiredToken:\n                    return Observable.of(connectionStatus, this.services.scheduler);\n\n                default:\n                    return Observable.of(connectionStatus, this.services.scheduler);\n            }\n        })\n\n        return once ? obs.take(1) : obs;\n    }\n\n    setConnectionStatusFallback(\n        connectionStatusFrom: ConnectionStatus,\n        connectionStatusTo: ConnectionStatus,\n        maxAttempts = 5\n    ) {\n        maxAttempts--;\n        let attempts = 0;\n        let currStatus = null;\n        return (status: ConnectionStatus): ConnectionStatus => {\n            if (status === connectionStatusFrom && currStatus === status && attempts >= maxAttempts) {\n                attempts = 0\n                return connectionStatusTo;\n            }\n            attempts++;\n            currStatus = status;\n            return status;\n        };\n    }\n\n    private expiredToken() {\n        const connectionStatus = this.connectionStatus$.getValue();\n        if (connectionStatus != ConnectionStatus.Ended && connectionStatus != ConnectionStatus.FailedToConnect)\n            this.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n\n        const protectedConnectionStatus = this.expiredTokenExhaustion(this.connectionStatus$.getValue());\n        this.connectionStatus$.next(protectedConnectionStatus);\n    }\n\n    private startConversation() {\n        //if conversationid is set here, it means we need to call the reconnect api, else it is a new conversation\n        const url = this.conversationId\n            ? `${this.domain}/conversations/${this.conversationId}?watermark=${this.watermark}`\n            : `${this.domain}/conversations`;\n        const method = this.conversationId ? \"GET\" : \"POST\";\n        const body = this.conversationId\n            ? undefined\n            : {\n                locale: this.localeOnStartConversation\n              };\n        return this.services.ajax({\n            method,\n            url,\n            body,\n            timeout: this.timeout,\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/json\",\n                ...this.commonHeaders()\n            }\n        })\n//      .do(ajaxResponse => konsole.log(\"conversation ajaxResponse\", ajaxResponse.response))\n        .map(ajaxResponse => ajaxResponse.response as Conversation)\n        .retryWhen(error$ =>\n            // for now we deem 4xx and 5xx errors as unrecoverable\n            // for everything else (timeouts), retry for a while\n            error$.mergeMap((error) => {\n                return error.status >= 400 && error.status < 600\n                ? Observable.throw(error, this.services.scheduler)\n                : Observable.of(error, this.services.scheduler)\n            })\n            .delay(this.timeout, this.services.scheduler)\n            .take(this.retries)\n        )\n    }\n\n    private refreshTokenLoop() {\n        this.tokenRefreshSubscription = Observable.interval(intervalRefreshToken, this.services.scheduler)\n        .flatMap(_ => this.refreshToken())\n        .subscribe(token => {\n            konsole.log(\"refreshing token\", token, \"at\", new Date());\n            this.token = token;\n        });\n    }\n\n    private refreshToken() {\n        return this.checkConnection(true)\n        .flatMap(_ =>\n            this.services.ajax({\n                method: \"POST\",\n                url: `${this.domain}/tokens/refresh`,\n                timeout: this.timeout,\n                headers: {\n                    ...this.commonHeaders()\n                }\n            })\n            .map(ajaxResponse => ajaxResponse.response.token as string)\n            .retryWhen(error$ => error$\n                .mergeMap(error => {\n                    if (error.status === 403) {\n                        // if the token is expired there's no reason to keep trying\n                        this.expiredToken();\n                        return Observable.throw(error, this.services.scheduler);\n                    } else if (error.status === 404) {\n                        // If the bot is gone, we should stop retrying\n                        return Observable.throw(error, this.services.scheduler);\n                    }\n\n                    return Observable.of(error, this.services.scheduler);\n                })\n                .delay(this.timeout, this.services.scheduler)\n                .take(this.retries)\n            )\n        )\n    }\n\n    public reconnect(conversation: Conversation) {\n        this.token = conversation.token;\n        this.streamUrl = conversation.streamUrl;\n        if (this.connectionStatus$.getValue() === ConnectionStatus.ExpiredToken)\n            this.connectionStatus$.next(ConnectionStatus.Online);\n    }\n\n    end() {\n        if (this.tokenRefreshSubscription)\n            this.tokenRefreshSubscription.unsubscribe();\n        try {\n            this.connectionStatus$.next(ConnectionStatus.Ended);\n        } catch (e) {\n            if (e === errorConversationEnded)\n                return;\n            throw(e);\n        }\n    }\n\n    getSessionId(): Observable<string> {\n        // If we're not connected to the bot, get connected\n        // Will throw an error if we are not connected\n        konsole.log(\"getSessionId\");\n        return this.checkConnection(true)\n            .flatMap(_ =>\n                this.services.ajax({\n                    method: \"GET\",\n                    url: `${this.domain}/session/getsessionid`,\n                    withCredentials: true,\n                    timeout: this.timeout,\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...this.commonHeaders()\n                    }\n                })\n                .map(ajaxResponse => {\n                    if (ajaxResponse && ajaxResponse.response && ajaxResponse.response.sessionId) {\n                        konsole.log(\"getSessionId response: \" + ajaxResponse.response.sessionId);\n                        return ajaxResponse.response.sessionId as string;\n                    }\n                    return '';\n                })\n                .catch(error => {\n                    konsole.log(\"getSessionId error: \" + error.status);\n                    return Observable.of('', this.services.scheduler);\n                })\n            )\n            .catch(error => this.catchExpiredToken(error));\n    }\n\n    postActivity(activity: Activity) {\n        // Use postMessageWithAttachments for messages with attachments that are local files (e.g. an image to upload)\n        // Technically we could use it for *all* activities, but postActivity is much lighter weight\n        // So, since WebChat is partially a reference implementation of Direct Line, we implement both.\n        if (activity.type === \"message\" && activity.attachments && activity.attachments.length > 0)\n            return this.postMessageWithAttachments(activity);\n\n        // If we're not connected to the bot, get connected\n        // Will throw an error if we are not connected\n        konsole.log(\"postActivity\", activity);\n        return this.checkConnection(true)\n        .flatMap(_ =>\n            this.services.ajax({\n                method: \"POST\",\n                url: `${this.domain}/conversations/${this.conversationId}/activities`,\n                body: activity,\n                timeout: this.timeout,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...this.commonHeaders()\n                },\n            })\n            .map(ajaxResponse => ajaxResponse.response.id as string)\n            .catch(error => this.catchPostError(error))\n        )\n        .catch(error => this.catchExpiredToken(error));\n    }\n\n    private postMessageWithAttachments(message: Message) {\n        const { attachments } = message;\n        // We clean the attachments but making sure every attachment has unique name.\n        // If the file do not have a name, Chrome will assign \"blob\" when it is appended to FormData.\n        const attachmentNames: string[] = dedupeFilenames(attachments.map((media: Media) => media.name || 'blob'));\n        const cleansedAttachments = attachments.map((attachment: Media, index: number) => ({\n            ...attachment,\n            name: attachmentNames[index]\n        }));\n        let formData: FormData;\n\n        // If we're not connected to the bot, get connected\n        // Will throw an error if we are not connected\n        return this.checkConnection(true)\n        .flatMap(_ => {\n            // To send this message to DirectLine we need to deconstruct it into a \"template\" activity\n            // and one blob for each attachment.\n            formData = new FormData();\n            formData.append('activity', new Blob([JSON.stringify({\n                ...message,\n                // Removing contentUrl from attachment, we will send it via multipart\n                attachments: cleansedAttachments.map(({ contentUrl: string, ...others }) => ({ ...others }))\n            })], { type: 'application/vnd.microsoft.activity' }));\n\n            return Observable.from(cleansedAttachments, this.services.scheduler)\n            .flatMap((media: Media) =>\n                this.services.ajax({\n                    method: \"GET\",\n                    url: media.contentUrl,\n                    responseType: 'arraybuffer'\n                })\n                .do(ajaxResponse =>\n                    formData.append('file', new Blob([ajaxResponse.response], { type: media.contentType }), media.name)\n                )\n            )\n            .count()\n        })\n        .flatMap(_ =>\n            this.services.ajax({\n                method: \"POST\",\n                url: `${this.domain}/conversations/${this.conversationId}/upload?userId=${message.from.id}`,\n                body: formData,\n                timeout: this.timeout,\n                headers: {\n                    ...this.commonHeaders()\n                }\n            })\n            .map(ajaxResponse => ajaxResponse.response.id as string)\n            .catch(error => this.catchPostError(error))\n        )\n        .catch(error => this.catchPostError(error));\n    }\n\n    private catchPostError(error: any) {\n        if (error.status === 403)\n            // token has expired (will fall through to return \"retry\")\n            this.expiredToken();\n        else if (error.status >= 400 && error.status < 500)\n            // more unrecoverable errors\n            return Observable.throw(error, this.services.scheduler);\n        return Observable.of(\"retry\", this.services.scheduler);\n    }\n\n    private catchExpiredToken(error: any) {\n        return error === errorExpiredToken\n        ? Observable.of(\"retry\", this.services.scheduler)\n        : Observable.throw(error, this.services.scheduler);\n    }\n\n    private pollingGetActivity$() {\n        const poller$: Observable<AjaxResponse> = Observable.create((subscriber: Subscriber<any>) => {\n            // A BehaviorSubject to trigger polling. Since it is a BehaviorSubject\n            // the first event is produced immediately.\n            const trigger$ = new BehaviorSubject<any>({});\n\n            // TODO: remove Date.now, use reactive interval to space out every request\n\n            trigger$.subscribe(() => {\n                if (this.connectionStatus$.getValue() === ConnectionStatus.Online) {\n                    const startTimestamp = Date.now();\n\n                    this.services.ajax({\n                        headers: {\n                            Accept: 'application/json',\n                            ...this.commonHeaders()\n                        },\n                        method: 'GET',\n                        url: `${ this.domain }/conversations/${ this.conversationId }/activities?watermark=${ this.watermark }`,\n                        timeout: this.timeout\n                    }).subscribe(\n                        (result: AjaxResponse) => {\n                            subscriber.next(result);\n                            setTimeout(() => trigger$.next(null), Math.max(0, this.pollingInterval - Date.now() + startTimestamp));\n                        },\n                        (error: any) => {\n                            switch (error.status) {\n                                case 403:\n                                    this.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n                                    setTimeout(() => trigger$.next(null), this.pollingInterval);\n                                    break;\n\n                                case 404:\n                                    this.connectionStatus$.next(ConnectionStatus.Ended);\n                                    break;\n\n                                default:\n                                    // propagate the error\n                                    subscriber.error(error);\n                                    break;\n                            }\n                        }\n                    );\n                }\n            });\n        });\n\n        return this.checkConnection()\n        .flatMap(_ => poller$\n            .catch(() => Observable.empty<AjaxResponse>())\n            .map(ajaxResponse => ajaxResponse.response as ActivityGroup)\n            .flatMap(activityGroup => this.observableFromActivityGroup(activityGroup)));\n    }\n\n    private observableFromActivityGroup(activityGroup: ActivityGroup) {\n        if (activityGroup.watermark)\n            this.watermark = activityGroup.watermark;\n        return Observable.from(activityGroup.activities, this.services.scheduler);\n    }\n\n    private webSocketActivity$(): Observable<Activity> {\n        return this.checkConnection()\n        .flatMap(_ =>\n            this.observableWebSocket<ActivityGroup>()\n            // WebSockets can be closed by the server or the browser. In the former case we need to\n            // retrieve a new streamUrl. In the latter case we could first retry with the current streamUrl,\n            // but it's simpler just to always fetch a new one.\n            .retryWhen(error$ => error$.delay(this.getRetryDelay(), this.services.scheduler).mergeMap(error => this.reconnectToConversation()))\n        )\n        .flatMap(activityGroup => this.observableFromActivityGroup(activityGroup))\n    }\n\n    // Returns the delay duration in milliseconds\n    private getRetryDelay() {\n        return Math.floor(3000 + this.services.random() * 12000);\n    }\n\n    // Originally we used Observable.webSocket, but it's fairly opinionated and I ended up writing\n    // a lot of code to work around their implementation details. Since WebChat is meant to be a reference\n    // implementation, I decided roll the below, where the logic is more purposeful. - @billba\n    private observableWebSocket<T>() {\n        return Observable.create((subscriber: Subscriber<T>) => {\n            konsole.log(\"creating WebSocket\", this.streamUrl);\n            const ws = new this.services.WebSocket(this.streamUrl);\n            let sub: Subscription;\n\n            ws.onopen = open => {\n                konsole.log(\"WebSocket open\", open);\n                // Chrome is pretty bad at noticing when a WebSocket connection is broken.\n                // If we periodically ping the server with empty messages, it helps Chrome\n                // realize when connection breaks, and close the socket. We then throw an\n                // error, and that give us the opportunity to attempt to reconnect.\n                sub = Observable.interval(this.timeout, this.services.scheduler).subscribe(_ => {\n                    try {\n                        ws.send(\"\")\n                    } catch(e) {\n                        konsole.log(\"Ping error\", e);\n                    }\n                });\n            }\n\n            ws.onclose = close => {\n                konsole.log(\"WebSocket close\", close);\n                if (sub) sub.unsubscribe();\n                subscriber.error(close);\n            }\n\n            ws.onmessage = message => message.data && subscriber.next(JSON.parse(message.data));\n\n            // This is the 'unsubscribe' method, which is called when this observable is disposed.\n            // When the WebSocket closes itself, we throw an error, and this function is eventually called.\n            // When the observable is closed first (e.g. when tearing down a WebChat instance) then\n            // we need to manually close the WebSocket.\n            return () => {\n                if (ws.readyState === 0 || ws.readyState === 1) ws.close();\n            }\n        }) as Observable<T>\n    }\n\n    private reconnectToConversation() {\n        return this.checkConnection(true)\n        .flatMap(_ =>\n            this.services.ajax({\n                method: \"GET\",\n                url: `${this.domain}/conversations/${this.conversationId}?watermark=${this.watermark}`,\n                timeout: this.timeout,\n                headers: {\n                    \"Accept\": \"application/json\",\n                    ...this.commonHeaders()\n                }\n            })\n            .do(result => {\n                if (!this.secret)\n                    this.token = result.response.token;\n                this.streamUrl = result.response.streamUrl;\n            })\n            .map(_ => null)\n            .retryWhen(error$ => error$\n                .mergeMap(error => {\n                    if (error.status === 403) {\n                        // token has expired. We can't recover from this here, but the embedding\n                        // website might eventually call reconnect() with a new token and streamUrl.\n                        this.expiredToken();\n                    } else if (error.status === 404) {\n                        return Observable.throw(errorConversationEnded, this.services.scheduler);\n                    }\n\n                    return Observable.of(error, this.services.scheduler);\n                })\n                .delay(this.timeout, this.services.scheduler)\n                .take(this.retries)\n            )\n        )\n    }\n\n    private commonHeaders() {\n        return {\n            \"Authorization\": `Bearer ${this.token}`,\n            \"x-ms-bot-agent\": this._botAgent\n        };\n    }\n\n    private getBotAgent(customAgent: string = ''): string {\n        let clientAgent = 'directlinejs'\n\n        if (customAgent) {\n            clientAgent += `; ${customAgent}`\n        }\n\n        return `${DIRECT_LINE_VERSION} (${clientAgent} ${process.env.npm_package_version})`;\n    }\n\n\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}